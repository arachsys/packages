diff --git a/vendor/bindgen/src/clang.rs b/vendor/bindgen/src/clang.rs
index 587cc0b..72fd042 100644
--- a/vendor/bindgen/src/clang.rs
+++ b/vendor/bindgen/src/clang.rs
@@ -52,6 +52,11 @@ impl Cursor {
         unsafe { clang_isDeclaration(self.kind()) != 0 }
     }
 
+    /// Is this cursor's referent an anonymous record or so?
+    pub fn is_anonymous(&self) -> bool {
+        unsafe { clang_Cursor_isAnonymous(self.x) != 0 }
+    }
+
     /// Get this cursor's referent's spelling.
     pub fn spelling(&self) -> String {
         unsafe { cxstring_into_string(clang_getCursorSpelling(self.x)) }
diff --git a/vendor/bindgen/src/ir/comp.rs b/vendor/bindgen/src/ir/comp.rs
index a221e52..b6a7561 100644
--- a/vendor/bindgen/src/ir/comp.rs
+++ b/vendor/bindgen/src/ir/comp.rs
@@ -1403,8 +1403,7 @@ impl CompInfo {
 
                         // A declaration of an union or a struct without name
                         // could also be an unnamed field, unfortunately.
-                        if cur.spelling().is_empty() &&
-                            cur.kind() != CXCursor_EnumDecl
+                        if cur.is_anonymous() && cur.kind() != CXCursor_EnumDecl
                         {
                             let ty = cur.cur_type();
                             let public = cur.public_accessible();
diff --git a/vendor/bindgen/src/ir/ty.rs b/vendor/bindgen/src/ir/ty.rs
index d573408..cad3f14 100644
--- a/vendor/bindgen/src/ir/ty.rs
+++ b/vendor/bindgen/src/ir/ty.rs
@@ -698,7 +698,12 @@ impl Type {
 
         let layout = ty.fallible_layout(ctx).ok();
         let cursor = ty.declaration();
-        let mut name = cursor.spelling();
+        let is_anonymous = cursor.is_anonymous();
+        let mut name = if is_anonymous {
+            None
+        } else {
+            Some(cursor.spelling()).filter(|n| !n.is_empty())
+        };
 
         debug!(
             "from_clang_ty: {:?}, ty: {:?}, loc: {:?}",
@@ -732,7 +737,7 @@ impl Type {
             if is_canonical_objcpointer && is_template_type_param {
                 // Objective-C generics are just ids with fancy name.
                 // To keep it simple, just name them ids
-                name = "id".to_owned();
+                name = Some("id".to_owned());
             }
         }
 
@@ -861,7 +866,7 @@ impl Type {
                                         return Err(ParseError::Recurse);
                                     }
                                 } else {
-                                    name = location.spelling();
+                                    name = Some(location.spelling());
                                 }
 
                                 let complex = CompInfo::from_ty(
@@ -903,7 +908,7 @@ impl Type {
                                                 CXType_Typedef
                                             );
 
-                                            name = current.spelling();
+                                            name = Some(location.spelling());
 
                                             let inner_ty = cur
                                                 .typedef_type()
@@ -1096,10 +1101,10 @@ impl Type {
                 CXType_Enum => {
                     let enum_ = Enum::from_ty(ty, ctx).expect("Not an enum?");
 
-                    if name.is_empty() {
+                    if !is_anonymous {
                         let pretty_name = ty.spelling();
                         if clang::is_valid_identifier(&pretty_name) {
-                            name = pretty_name;
+                            name = Some(pretty_name);
                         }
                     }
 
@@ -1114,12 +1119,12 @@ impl Type {
                     )
                     .expect("Not a complex type?");
 
-                    if name.is_empty() {
+                    if !is_anonymous {
                         // The pretty-printed name may contain typedefed name,
                         // but may also be "struct (anonymous at .h:1)"
                         let pretty_name = ty.spelling();
                         if clang::is_valid_identifier(&pretty_name) {
-                            name = pretty_name;
+                            name = Some(pretty_name);
                         }
                     }
 
@@ -1159,7 +1164,9 @@ impl Type {
                 CXType_ObjCClass | CXType_ObjCInterface => {
                     let interface = ObjCInterface::from_ty(&location, ctx)
                         .expect("Not a valid objc interface?");
-                    name = interface.rust_name();
+                    if !is_anonymous {
+                        name = Some(interface.rust_name());
+                    }
                     TypeKind::ObjCInterface(interface)
                 }
                 CXType_Dependent => {
@@ -1177,7 +1184,7 @@ impl Type {
             }
         };
 
-        let name = if name.is_empty() { None } else { Some(name) };
+        name = name.filter(|n| !n.is_empty());
 
         let is_const = ty.is_const() ||
             (ty.kind() == CXType_ConstantArray &&
