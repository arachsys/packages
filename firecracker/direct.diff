diff --git a/src/vmm/src/devices/virtio/block/device.rs b/src/vmm/src/devices/virtio/block/device.rs
index 43b7706..fc9e24e 100644
--- a/src/vmm/src/devices/virtio/block/device.rs
+++ b/src/vmm/src/devices/virtio/block/device.rs
@@ -10,6 +10,7 @@ use std::convert::From;
 use std::fs::{File, OpenOptions};
 use std::io::{Seek, SeekFrom, Write};
 use std::os::linux::fs::MetadataExt;
+use std::os::unix::fs::OpenOptionsExt;
 use std::path::PathBuf;
 use std::sync::atomic::AtomicUsize;
 use std::sync::Arc;
@@ -77,6 +78,7 @@ impl FileEngineType {
 #[derive(Debug)]
 pub(crate) struct DiskProperties {
     cache_type: CacheType,
+    is_disk_direct_io: bool,
     file_path: String,
     file_engine: FileEngine<PendingRequest>,
     nsectors: u64,
@@ -85,10 +87,12 @@ pub(crate) struct DiskProperties {
 
 impl DiskProperties {
     // Helper function that opens the file with the proper access permissions
-    fn open_file(disk_image_path: &str, is_disk_read_only: bool) -> Result<File, BlockError> {
+    fn open_file(disk_image_path: &str, is_disk_read_only: bool, is_disk_direct_io: bool) -> Result<File, BlockError> {
+        let custom_flags = if is_disk_direct_io { libc::O_DIRECT } else { 0 };
         OpenOptions::new()
             .read(true)
             .write(!is_disk_read_only)
+            .custom_flags(custom_flags)
             .open(PathBuf::from(&disk_image_path))
             .map_err(|x| BlockError::BackingFile(x, disk_image_path.to_string()))
     }
@@ -116,14 +120,16 @@ impl DiskProperties {
     pub fn new(
         disk_image_path: String,
         is_disk_read_only: bool,
+        is_disk_direct_io: bool,
         cache_type: CacheType,
         file_engine_type: FileEngineType,
     ) -> Result<Self, BlockError> {
-        let mut disk_image = Self::open_file(&disk_image_path, is_disk_read_only)?;
+        let mut disk_image = Self::open_file(&disk_image_path, is_disk_read_only, is_disk_direct_io)?;
         let disk_size = Self::file_size(&disk_image_path, &mut disk_image)?;
 
         Ok(Self {
             cache_type,
+            is_disk_direct_io,
             nsectors: disk_size >> SECTOR_SHIFT,
             image_id: Self::build_disk_image_id(&disk_image),
             file_path: disk_image_path,
@@ -137,8 +143,9 @@ impl DiskProperties {
         &mut self,
         disk_image_path: String,
         is_disk_read_only: bool,
+        is_disk_direct_io: bool,
     ) -> Result<(), BlockError> {
-        let mut disk_image = Self::open_file(&disk_image_path, is_disk_read_only)?;
+        let mut disk_image = Self::open_file(&disk_image_path, is_disk_read_only, is_disk_direct_io)?;
         let disk_size = Self::file_size(&disk_image_path, &mut disk_image)?;
 
         self.image_id = Self::build_disk_image_id(&disk_image);
@@ -273,12 +280,14 @@ impl Block {
         disk_image_path: String,
         is_disk_read_only: bool,
         is_disk_root: bool,
+        is_disk_direct_io: bool,
         rate_limiter: RateLimiter,
         file_engine_type: FileEngineType,
     ) -> Result<Block, BlockError> {
         let disk_properties = DiskProperties::new(
             disk_image_path,
             is_disk_read_only,
+            is_disk_direct_io,
             cache_type,
             file_engine_type,
         )?;
@@ -485,7 +494,7 @@ impl Block {
 
     /// Update the backing file and the config space of the block device.
     pub fn update_disk_image(&mut self, disk_image_path: String) -> Result<(), BlockError> {
-        self.disk.update(disk_image_path, self.is_read_only())?;
+        self.disk.update(disk_image_path, self.is_read_only(), self.is_direct_io())?;
         self.config_space = self.disk.virtio_block_config_space();
 
         // Kick the driver to pick up the changes.
@@ -520,6 +529,11 @@ impl Block {
         self.avail_features & (1u64 << VIRTIO_BLK_F_RO) != 0
     }
 
+    /// Specifies if this block device uses direct IO.
+    pub fn is_direct_io(&self) -> bool {
+        self.disk.is_disk_direct_io
+    }
+
     /// Specifies if this block device is read only.
     pub fn is_root_device(&self) -> bool {
         self.root_device
diff --git a/src/vmm/src/devices/virtio/block/persist.rs b/src/vmm/src/devices/virtio/block/persist.rs
index b3f1b29..e4208ca 100644
--- a/src/vmm/src/devices/virtio/block/persist.rs
+++ b/src/vmm/src/devices/virtio/block/persist.rs
@@ -103,6 +103,8 @@ pub struct BlockState {
     // v1.0 are incompatible with older FC versions (due to incompatible notification suppression
     // feature).
     file_engine_type: FileEngineTypeState,
+    #[version(start = 4, default_fn = "default_is_direct_io")]
+    is_direct_io: bool,
 }
 
 impl BlockState {
@@ -120,6 +122,10 @@ impl BlockState {
     fn default_cache_type_flush(_source_version: u16) -> CacheTypeState {
         CacheTypeState::Unsafe
     }
+
+    fn default_is_direct_io(_source_version: u16) -> bool {
+        false
+    }
 }
 
 /// Auxiliary structure for creating a device when resuming from a snapshot.
@@ -141,6 +147,7 @@ impl Persist<'_> for Block {
             partuuid: self.partuuid.clone(),
             cache_type: CacheTypeState::from(self.cache_type()),
             root_device: self.root_device,
+            is_direct_io: self.is_direct_io(),
             disk_path: self.disk.file_path().clone(),
             virtio_state: VirtioDeviceState::from_device(self),
             rate_limiter_state: self.rate_limiter.save(),
@@ -163,6 +170,7 @@ impl Persist<'_> for Block {
             state.disk_path.clone(),
             is_disk_read_only,
             state.root_device,
+            state.is_direct_io,
             rate_limiter,
             state.file_engine_type.into(),
         )
@@ -184,6 +192,7 @@ impl Persist<'_> for Block {
                     state.disk_path.clone(),
                     is_disk_read_only,
                     state.root_device,
+                    state.is_direct_io,
                     rate_limiter,
                     FileEngineType::Sync,
                 )
diff --git a/src/vmm/src/devices/virtio/block/test_utils.rs b/src/vmm/src/devices/virtio/block/test_utils.rs
index 4e76d79..c876429 100644
--- a/src/vmm/src/devices/virtio/block/test_utils.rs
+++ b/src/vmm/src/devices/virtio/block/test_utils.rs
@@ -54,6 +54,7 @@ pub fn default_block_with_path(path: String, file_engine_type: FileEngineType) -
         path,
         false,
         false,
+        false,
         rate_limiter,
         file_engine_type,
     )
diff --git a/src/vmm/src/version_map.rs b/src/vmm/src/version_map.rs
index c433dde..b345923 100644
--- a/src/vmm/src/version_map.rs
+++ b/src/vmm/src/version_map.rs
@@ -65,10 +65,8 @@ lazy_static! {
         #[cfg(target_arch = "x86_64")]
         version_map.set_type_version(VcpuState::type_id(), 3);
 
-        // v1.3 - no changes introduced, but we need to bump as mapping
-        // between firecracker minor versions and snapshot versions needs
-        // to be 1-to-1 (see below)
-        version_map.new_version();
+        // v1.3 state change mappings.
+        version_map.new_version().set_type_version(BlockState::type_id(), 4);
 
         // v1.4 state change mappings.
         version_map.new_version().set_type_version(DeviceStates::type_id(), 4);
diff --git a/src/vmm/src/vmm_config/drive.rs b/src/vmm/src/vmm_config/drive.rs
index f3a9883..16c6ae4 100644
--- a/src/vmm/src/vmm_config/drive.rs
+++ b/src/vmm/src/vmm_config/drive.rs
@@ -60,6 +60,9 @@ pub struct BlockDeviceConfig {
     #[serde(default)]
     #[serde(rename = "io_engine")]
     pub file_engine_type: FileEngineType,
+    /// If set to true, the disk is opened using direct IO.
+    #[serde(default)]
+    pub is_direct_io: bool,
 }
 
 impl From<&Block> for BlockDeviceConfig {
@@ -71,6 +74,7 @@ impl From<&Block> for BlockDeviceConfig {
             is_root_device: block.is_root_device(),
             partuuid: block.partuuid().cloned(),
             is_read_only: block.is_read_only(),
+            is_direct_io: block.is_direct_io(),
             cache_type: block.cache_type(),
             rate_limiter: rl.into_option(),
             file_engine_type: block.file_engine_type(),
@@ -199,6 +203,7 @@ impl BlockBuilder {
             block_device_config.path_on_host,
             block_device_config.is_read_only,
             block_device_config.is_root_device,
+            block_device_config.is_direct_io,
             rate_limiter.unwrap_or_default(),
             block_device_config.file_engine_type,
         )
