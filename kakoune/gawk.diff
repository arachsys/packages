diff --git a/rc/tools/git.kak b/rc/tools/git.kak
index c6fd7ff..b5c73b8 100644
--- a/rc/tools/git.kak
+++ b/rc/tools/git.kak
@@ -138,36 +138,42 @@ define-command -params 1.. \
                       try %{ add-highlighter window/git-blame flag-lines Information git_blame_flags }
                       set-option buffer=$kak_bufname git_blame_flags '$kak_timestamp'
                   }" | kak -p ${kak_session}
-                  git blame "$@" --incremental ${kak_buffile} | perl -wne '
-                  use POSIX qw(strftime);
-                  sub send_flags {
-                      my $flush = shift;
-                      if (not defined $line) { return; }
-                      my $text = substr($sha,1,8) . " " . $dates{$sha} . " " . $authors{$sha};
-                      $text =~ s/~/~~/g;
-                      for ( my $i = 0; $i < $count; $i++ ) {
-                          $flags .= " %~" . ($line+$i) . "|$text~";
-                      }
-                      $now = time();
-                      # Send roughly one update per second, to avoid creating too many kak processes.
-                      if (!$flush && defined $last_sent && $now - $last_sent < 1) {
-                          return
-                      }
-                      open CMD, "|-", "kak -p $ENV{kak_session}";
-                      print CMD "set-option -add buffer=$ENV{kak_bufname} git_blame_flags $flags";
-                      close(CMD);
-                      $flags = "";
-                      $last_sent = $now;
-                  }
-                  if (m/^([0-9a-f]+) ([0-9]+) ([0-9]+) ([0-9]+)/) {
-                      send_flags(0);
-                      $sha = $1;
-                      $line = $3;
-                      $count = $4;
-                  }
-                  if (m/^author /) { $authors{$sha} = substr($_,7) }
-                  if (m/^author-time ([0-9]*)/) { $dates{$sha} = strftime("%F %T", localtime $1) }
-                  END { send_flags(1); }'
+            git blame "$@" --incremental ${kak_buffile} | gawk '
+            function send(flush) {
+                if (line == "")
+                  return
+                text = substr(sha, 1, 8) " " dates[sha] " " authors[sha]
+                gsub("~", "~~", text)
+                for (i = 0; i < count; i++)
+                    flags = flags " %~" (line + i) "|" text "~"
+                now = systime()
+                if (!flush && now < last + 1)
+                    return
+                cmd = "kak -p " ENVIRON["kak_session"]
+                print "set-option -add buffer=" ENVIRON["kak_bufname"] " git_blame_flags " flags | cmd
+                close(cmd)
+                flags = ""
+                last = now
+            }
+
+            /^([0-9a-f]+) ([0-9]+) ([0-9]+) ([0-9]+)/ {
+                send(0)
+                sha = $1
+                line = $3
+                count = $4
+            }
+
+            /^author / {
+                authors[sha] = substr($0, 8)
+            }
+
+            /^author-time ([0-9]*)/ {
+                dates[sha] = strftime("%F %T", $2)
+            }
+
+            END {
+                send(1)
+            }'
         ) > /dev/null 2>&1 < /dev/null &
     }
 
diff --git a/rc/tools/patch-range.pl b/rc/tools/patch-range.pl
deleted file mode 100755
index 10cc74f..0000000
--- a/rc/tools/patch-range.pl
+++ /dev/null
@@ -1,93 +0,0 @@
-#!/usr/bin/env perl
-
-use strict;
-use warnings;
-
-my $min_line = $ARGV[0];
-shift @ARGV;
-my $max_line = $ARGV[0];
-shift @ARGV;
-
-my $patch_cmd;
-if (defined $ARGV[0] and $ARGV[0] =~ m{^[^-]}) {
-    $patch_cmd = "@ARGV";
-} else {
-    $patch_cmd = "patch @ARGV";
-}
-my $reverse = grep /^(--reverse|-R)$/, @ARGV;
-
-my $lineno = 0;
-my $original = "";
-my $wheat = "";
-my $chaff = "";
-my $state = undef;
-my $hunk_wheat = undef;
-my $hunk_chaff = undef;
-my $hunk_header = undef;
-
-sub compute_hunk_header {
-    my $original_header = shift;
-    my $hunk = shift;
-    my $old_lines = 0;
-    my $new_lines = 0;
-    for (split /\n/, $hunk) {
-        $old_lines++ if m{^[ -]};
-        $new_lines++ if m{^[ +]};
-    }
-    my $updated_header = $original_header =~ s/^@@ -(\d+),\d+\s+\+(\d+),\d+ @@(.*)/@@ -$1,$old_lines +$2,$new_lines @\@$3/mr;
-    return $updated_header;
-}
-
-sub finish_hunk {
-    return unless defined $hunk_header;
-    if ($hunk_wheat =~ m{^[-+]}m) {
-        $wheat .= (compute_hunk_header $hunk_header, $hunk_wheat). $hunk_wheat;
-    }
-    $chaff .= (compute_hunk_header $hunk_header, $hunk_chaff) . $hunk_chaff;
-    $hunk_header = undef;
-}
-
-while (<STDIN>) {
-    ++$lineno;
-    $original .= $_;
-    if (m{^diff}) {
-        finish_hunk();
-        $state = "diff header";
-    }
-    if (m{^@@}) {
-        finish_hunk();
-        $state = "diff hunk";
-        $hunk_header = $_;
-        $hunk_wheat = "";
-        $hunk_chaff = "";
-        next;
-    }
-    if ($state eq "diff header") {
-        $wheat .= $_;
-        $chaff .= $_;
-        next;
-    }
-    my $include = m{^ } || ($lineno >= $min_line && $lineno <= $max_line);
-    if ($include) {
-        $hunk_wheat .= $_;
-        $hunk_chaff .= $_ if m{^ };
-        if ($reverse ? m{^[-]} : m{^\+}) {
-            $hunk_chaff .= " " . substr $_, 1;
-        }
-    } else {
-        if ($reverse ? m{^\+} : m{^-}) {
-            $hunk_wheat .= " " . substr $_, 1;
-        }
-        $hunk_chaff .= $_;
-    }
-}
-finish_hunk();
-
-open PATCH_COMMAND, "|-", "$patch_cmd 1>&2" or die "patch-range.pl: error running '$patch_cmd': $!";
-print PATCH_COMMAND $wheat;
-if (not close PATCH_COMMAND) {
-    print $original;
-    print STDERR "patch-range.pl: error running:\n" . "\$ $patch_cmd << EOF\n$wheat" . "EOF\n";
-    exit 1;
-}
-print $chaff;
diff --git a/rc/tools/patch.kak b/rc/tools/patch.kak
index fe635ac..2b6560e 100644
--- a/rc/tools/patch.kak
+++ b/rc/tools/patch.kak
@@ -49,13 +49,82 @@ define-command patch -params .. -docstring %{
                 min_line=$((min_line - kak_cursor_line + 1))
                 max_line=$((max_line - kak_cursor_line + 1))
 
-                # Since registers are never empty, we get an empty arg even if
-                # there were no args. This does no harm because we pass it to
-                # a shell where it expands to nothing.
-                eval set -- $kak_quoted_reg_a
+                # If there were no args, $kak_quoted_reg_a will contain a quoted empty string.
+                if ! gawk -v min_line=$min_line -v max_line=$max_line \
+                          -v patch="$kak_quoted_reg_a 1>&2" '
+                function complete() {
+                    if (hunk_header) {
+                        if (hunk_wheat ~ /(^|\n)[-+]/)
+                            wheat = wheat compute(hunk_header, hunk_wheat) hunk_wheat
+                        chaff = chaff compute(hunk_header, hunk_chaff) hunk_chaff
+                        hunk_header = ""
+                    }
+                }
 
-                perl "${kak_reg_f%/*}/patch-range.pl" $min_line $max_line "$@" ||
+                function compute(header, hunk) {
+                    old = new = 0
+                    split(hunk, lines, /\n/)
+                    for (line in lines) {
+                        if (lines[line] ~ /^[ -]/)
+                            old++
+                        if (lines[line] ~ /^[ +]/)
+                            new++
+                    }
+                    return gensub(/^(@@[\t ]+-[0-9]+),[0-9]+([\t ]+\+[0-9]+,)[0-9]+([\t ]+@@.*)/,
+                                  "\\1," old "\\2" new "\\3", "g", header)
+                }
+
+                BEGIN {
+                    if (sub(/^\047\047 /, "patch ", patch) == 0 && patch ~ /^\047?-/)
+                        patch = "patch " patch
+                    if (patch ~ /\047(-R|--reverse)\047($| )/)
+                        reverse = 1
+                }
+
+                {
+                    original = original $0 "\n"
+
+                    if (/^diff/) {
+                        complete()
+                        header = 1
+                    }
+
+                    if (/^@@/) {
+                        complete()
+                        hunk_header = $0 "\n"
+                        hunk_wheat = hunk_chaff = ""
+                        header = 0
+                        next
+                    }
+
+                    if (header) {
+                        wheat = wheat $0 "\n"
+                        chaff = chaff $0 "\n"
+                        next
+                    }
+
+                    if (/^ / || (NR >= min_line && NR <= max_line)) {
+                        hunk_wheat = hunk_wheat $0 "\n"
+                        if (reverse ? /^[- ]/ : /^[+ ]/)
+                            hunk_chaff = hunk_chaff " " substr($0, 2) "\n"
+                    } else {
+                        if (reverse ? /^[+]/ : /^[-]/)
+                            hunk_wheat = hunk_wheat " " substr($0, 2) "\n"
+                        hunk_chaff = hunk_chaff $0 "\n"
+                    }
+                }
+
+                END {
+                    complete()
+                    printf("%s", wheat) | patch
+                    if (close(patch)) {
+                        printf("%s", original)
+                        exit(1)
+                    }
+                    printf("%s", chaff)
+                }'; then
                     echo >$kak_command_fifo "set-register e fail 'patch: failed to apply selections, see *debug* buffer'"
+                fi
             }
             execute-keys |<ret>
             %reg{e}
