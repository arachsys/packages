diff --git a/clang/lib/Driver/ToolChains/Cuda.cpp b/clang/lib/Driver/ToolChains/Cuda.cpp
index 7ad990dda..ec73fd999 100644
--- a/clang/lib/Driver/ToolChains/Cuda.cpp
+++ b/clang/lib/Driver/ToolChains/Cuda.cpp
@@ -161,15 +161,7 @@ CudaInstallationDetector::CudaInstallationDetector(
       }
     }
 
-    Candidates.emplace_back(D.SysRoot + "/usr/local/cuda");
-    for (const char *Ver : Versions)
-      Candidates.emplace_back(D.SysRoot + "/usr/local/cuda-" + Ver);
-
-    Distro Dist(FS, llvm::Triple(llvm::sys::getProcessTriple()));
-    if (Dist.IsDebian() || Dist.IsUbuntu())
-      // Special case for Debian to have nvidia-cuda-toolkit work
-      // out of the box. More info on http://bugs.debian.org/882505
-      Candidates.emplace_back(D.SysRoot + "/usr/lib/cuda");
+    Candidates.emplace_back(D.SysRoot + "/lib/cuda");
   }
 
   bool NoCudaLib = Args.hasArg(options::OPT_nogpulib);
diff --git a/clang/lib/Driver/ToolChains/Gnu.cpp b/clang/lib/Driver/ToolChains/Gnu.cpp
index f203cae1d..b53ca1422 100644
--- a/clang/lib/Driver/ToolChains/Gnu.cpp
+++ b/clang/lib/Driver/ToolChains/Gnu.cpp
@@ -2135,39 +2135,7 @@ void Generic_GCC::GCCInstallationDetector::AddDefaultGCCPrefixes(
     return;
   }
 
-  // For Linux, if --sysroot is not specified, look for RHEL/CentOS devtoolsets
-  // and gcc-toolsets.
-  if (SysRoot.empty() && TargetTriple.getOS() == llvm::Triple::Linux &&
-      D.getVFS().exists("/opt/rh")) {
-    // Find the directory in /opt/rh/ starting with gcc-toolset-* or
-    // devtoolset-* with the highest version number and add that
-    // one to our prefixes.
-    std::string ChosenToolsetDir;
-    unsigned ChosenToolsetVersion = 0;
-    std::error_code EC;
-    for (llvm::vfs::directory_iterator LI = D.getVFS().dir_begin("/opt/rh", EC),
-                                       LE;
-         !EC && LI != LE; LI = LI.increment(EC)) {
-      StringRef ToolsetDir = llvm::sys::path::filename(LI->path());
-      unsigned ToolsetVersion;
-      if ((!ToolsetDir.startswith("gcc-toolset-") &&
-           !ToolsetDir.startswith("devtoolset-")) ||
-          ToolsetDir.substr(ToolsetDir.rfind('-') + 1)
-              .getAsInteger(10, ToolsetVersion))
-        continue;
-
-      if (ToolsetVersion > ChosenToolsetVersion) {
-        ChosenToolsetVersion = ToolsetVersion;
-        ChosenToolsetDir = "/opt/rh/" + ToolsetDir.str();
-      }
-    }
-
-    if (ChosenToolsetVersion > 0)
-      Prefixes.push_back(ChosenToolsetDir + "/root/usr");
-  }
-
-  // Fall back to /usr which is used by most non-Solaris systems.
-  Prefixes.push_back(concat(SysRoot, "/usr"));
+  Prefixes.push_back(SysRoot.str());
 }
 
 /*static*/ void Generic_GCC::GCCInstallationDetector::CollectLibDirsAndTriples(
@@ -3043,14 +3011,12 @@ Generic_GCC::addLibCxxIncludePaths(const llvm::opt::ArgList &DriverArgs,
   // Android never uses the libc++ headers installed alongside the toolchain,
   // which are generally incompatible with the NDK libraries anyway.
   if (!getTriple().isAndroid())
-    if (AddIncludePath(getDriver().Dir + "/../include"))
+    if (AddIncludePath(getDriver().Dir + "/include"))
       return;
   // If this is a development, non-installed, clang, libcxx will
   // not be found at ../include/c++ but it likely to be found at
   // one of the following two locations:
-  if (AddIncludePath(concat(SysRoot, "/usr/local/include")))
-    return;
-  if (AddIncludePath(concat(SysRoot, "/usr/include")))
+  if (AddIncludePath(concat(SysRoot, "/lib/include")))
     return;
 }
 
@@ -3124,7 +3090,7 @@ bool Generic_GCC::addGCCLibStdCxxIncludePaths(
     return true;
 
   // Try /../include/c++/$version (gcc --print-multiarch is empty).
-  if (addLibStdCXXIncludePaths(LibDir.str() + "/../include/c++/" + Version.Text,
+  if (addLibStdCXXIncludePaths(LibDir.str() + "/include/c++/" + Version.Text,
                                TripleStr, Multilib.includeSuffix(), DriverArgs,
                                CC1Args))
     return true;
diff --git a/clang/lib/Driver/ToolChains/Linux.cpp b/clang/lib/Driver/ToolChains/Linux.cpp
index 71e1d9b16..3bcfa0ce0 100644
--- a/clang/lib/Driver/ToolChains/Linux.cpp
+++ b/clang/lib/Driver/ToolChains/Linux.cpp
@@ -125,7 +125,11 @@ std::string Linux::getMultiarchTriple(const Driver &D,
   return TargetTriple.str();
 }
 
-static StringRef getOSLibDir(const llvm::Triple &Triple, const ArgList &Args) {
+static StringRef getOSLibDir(const llvm::Triple &Triple,
+                             const Distro &Distro,
+                             const ArgList &Args) {
+  if (Distro.IsArachsys())
+    return "lib";
   if (Triple.isMIPS()) {
     if (Triple.isAndroid()) {
       StringRef CPUName;
@@ -179,13 +183,13 @@ Linux::Linux(const Driver &D, const llvm::Triple &Triple, const ArgList &Args)
 
   Distro Distro(D.getVFS(), Triple);
 
-  if (Distro.IsAlpineLinux() || Triple.isAndroid()) {
+  if (Distro.IsAlpineLinux() || Distro.IsArachsys() || Triple.isAndroid()) {
     ExtraOpts.push_back("-z");
     ExtraOpts.push_back("now");
   }
 
   if (Distro.IsOpenSUSE() || Distro.IsUbuntu() || Distro.IsAlpineLinux() ||
-      Triple.isAndroid()) {
+      Distro.IsArachsys() || Triple.isAndroid()) {
     ExtraOpts.push_back("-z");
     ExtraOpts.push_back("relro");
   }
@@ -227,7 +231,8 @@ Linux::Linux(const Driver &D, const llvm::Triple &Triple, const ArgList &Args)
   // Android loader does not support .gnu.hash until API 23.
   // Hexagon linker/loader does not support .gnu.hash
   if (!IsMips && !IsHexagon) {
-    if (Distro.IsRedhat() || Distro.IsOpenSUSE() || Distro.IsAlpineLinux() ||
+    if (Distro.IsRedhat() || Distro.IsOpenSUSE() ||
+        Distro.IsAlpineLinux() || Distro.IsArachsys() ||
         (Distro.IsUbuntu() && Distro >= Distro::UbuntuMaverick) ||
         (IsAndroid && !Triple.isAndroidVersionLT(23)))
       ExtraOpts.push_back("--hash-style=gnu");
@@ -253,20 +258,13 @@ Linux::Linux(const Driver &D, const llvm::Triple &Triple, const ArgList &Args)
   // to the link paths.
   path_list &Paths = getFilePaths();
 
-  const std::string OSLibDir = std::string(getOSLibDir(Triple, Args));
+  const std::string OSLibDir = std::string(getOSLibDir(Triple, Distro, Args));
   const std::string MultiarchTriple = getMultiarchTriple(D, Triple, SysRoot);
 
-  // mips32: Debian multilib, we use /libo32, while in other case, /lib is
-  // used. We need add both libo32 and /lib.
-  if (Arch == llvm::Triple::mips || Arch == llvm::Triple::mipsel) {
-    Generic_GCC::AddMultilibPaths(D, SysRoot, "libo32", MultiarchTriple, Paths);
-    addPathIfExists(D, concat(SysRoot, "/libo32"), Paths);
-    addPathIfExists(D, concat(SysRoot, "/usr/libo32"), Paths);
-  }
   Generic_GCC::AddMultilibPaths(D, SysRoot, OSLibDir, MultiarchTriple, Paths);
 
-  addPathIfExists(D, concat(SysRoot, "/lib", MultiarchTriple), Paths);
-  addPathIfExists(D, concat(SysRoot, "/lib/..", OSLibDir), Paths);
+  addPathIfExists(D, concat(SysRoot, "/", OSLibDir, "/shared"), Paths);
+  addPathIfExists(D, concat(SysRoot, "/", OSLibDir, "/static"), Paths);
 
   if (IsAndroid) {
     // Android sysroots contain a library directory for each supported OS
@@ -279,32 +277,7 @@ Linux::Linux(const Driver &D, const llvm::Triple &Triple, const ArgList &Args)
         Paths);
   }
 
-  addPathIfExists(D, concat(SysRoot, "/usr/lib", MultiarchTriple), Paths);
-  // 64-bit OpenEmbedded sysroots may not have a /usr/lib dir. So they cannot
-  // find /usr/lib64 as it is referenced as /usr/lib/../lib64. So we handle
-  // this here.
-  if (Triple.getVendor() == llvm::Triple::OpenEmbedded &&
-      Triple.isArch64Bit())
-    addPathIfExists(D, concat(SysRoot, "/usr", OSLibDir), Paths);
-  else
-    addPathIfExists(D, concat(SysRoot, "/usr/lib/..", OSLibDir), Paths);
-  if (IsRISCV) {
-    StringRef ABIName = tools::riscv::getRISCVABI(Args, Triple);
-    addPathIfExists(D, concat(SysRoot, "/", OSLibDir, ABIName), Paths);
-    addPathIfExists(D, concat(SysRoot, "/usr", OSLibDir, ABIName), Paths);
-  }
-
   Generic_GCC::AddMultiarchPaths(D, SysRoot, OSLibDir, Paths);
-
-  // The deprecated -DLLVM_ENABLE_PROJECTS=libcxx configuration installs
-  // libc++.so in D.Dir+"/../lib/". Detect this path.
-  // TODO Remove once LLVM_ENABLE_PROJECTS=libcxx is unsupported.
-  if (StringRef(D.Dir).startswith(SysRoot) &&
-      D.getVFS().exists(D.Dir + "/../lib/libc++.so"))
-    addPathIfExists(D, D.Dir + "/../lib", Paths);
-
-  addPathIfExists(D, concat(SysRoot, "/lib"), Paths);
-  addPathIfExists(D, concat(SysRoot, "/usr/lib"), Paths);
 }
 
 ToolChain::RuntimeLibType Linux::GetDefaultRuntimeLibType() const {
@@ -397,6 +370,9 @@ std::string Linux::getDynamicLinker(const ArgList &Args) const {
 
   const Distro Distro(getDriver().getVFS(), Triple);
 
+  if (Distro.IsArachsys())
+    return "/lib/ld.so";
+
   if (Triple.isAndroid())
     return Triple.isArch64Bit() ? "/system/bin/linker64" : "/system/bin/linker";
 
@@ -576,8 +552,6 @@ void Linux::AddClangSystemIncludeArgs(const ArgList &DriverArgs,
   if (DriverArgs.hasArg(options::OPT_nostdlibinc))
     return;
 
-  // LOCAL_INCLUDE_DIR
-  addSystemInclude(DriverArgs, CC1Args, concat(SysRoot, "/usr/local/include"));
   // TOOL_INCLUDE_DIR
   AddMultilibIncludeArgs(DriverArgs, CC1Args);
 
@@ -598,10 +572,10 @@ void Linux::AddClangSystemIncludeArgs(const ArgList &DriverArgs,
   // /usr/include.
   std::string MultiarchIncludeDir = getMultiarchTriple(D, getTriple(), SysRoot);
   if (!MultiarchIncludeDir.empty() &&
-      D.getVFS().exists(concat(SysRoot, "/usr/include", MultiarchIncludeDir)))
+      D.getVFS().exists(concat(SysRoot, "/lib/include", MultiarchIncludeDir)))
     addExternCSystemInclude(
         DriverArgs, CC1Args,
-        concat(SysRoot, "/usr/include", MultiarchIncludeDir));
+        concat(SysRoot, "/lib/include", MultiarchIncludeDir));
 
   if (getTriple().getOS() == llvm::Triple::RTEMS)
     return;
@@ -609,9 +583,7 @@ void Linux::AddClangSystemIncludeArgs(const ArgList &DriverArgs,
   // Add an include of '/include' directly. This isn't provided by default by
   // system GCCs, but is often used with cross-compiling GCCs, and harmless to
   // add even when Clang is acting as-if it were a system compiler.
-  addExternCSystemInclude(DriverArgs, CC1Args, concat(SysRoot, "/include"));
-
-  addExternCSystemInclude(DriverArgs, CC1Args, concat(SysRoot, "/usr/include"));
+  addExternCSystemInclude(DriverArgs, CC1Args, concat(SysRoot, "/lib/include"));
 
   if (!DriverArgs.hasArg(options::OPT_nobuiltininc) && getTriple().isMusl())
     addSystemInclude(DriverArgs, CC1Args, ResourceDirInclude);
diff --git a/clang/lib/Driver/ToolChains/WebAssembly.cpp b/clang/lib/Driver/ToolChains/WebAssembly.cpp
index b051bff87..dacf51e2a 100644
--- a/clang/lib/Driver/ToolChains/WebAssembly.cpp
+++ b/clang/lib/Driver/ToolChains/WebAssembly.cpp
@@ -416,9 +416,9 @@ void WebAssembly::AddClangSystemIncludeArgs(const ArgList &DriverArgs,
   if (getTriple().getOS() != llvm::Triple::UnknownOS) {
     const std::string MultiarchTriple =
         getMultiarchTriple(D, getTriple(), D.SysRoot);
-    addSystemInclude(DriverArgs, CC1Args, D.SysRoot + "/include/" + MultiarchTriple);
+    addSystemInclude(DriverArgs, CC1Args, D.SysRoot + "/lib/include/" + MultiarchTriple);
   }
-  addSystemInclude(DriverArgs, CC1Args, D.SysRoot + "/include");
+  addSystemInclude(DriverArgs, CC1Args, D.SysRoot + "/lib/include");
 }
 
 void WebAssembly::AddClangCXXStdlibIncludeArgs(const ArgList &DriverArgs,
@@ -471,7 +471,7 @@ void WebAssembly::addLibCxxIncludePaths(
     llvm::opt::ArgStringList &CC1Args) const {
   const Driver &D = getDriver();
   std::string SysRoot = computeSysRoot();
-  std::string LibPath = SysRoot + "/include";
+  std::string LibPath = SysRoot + "/lib/include";
   const std::string MultiarchTriple =
       getMultiarchTriple(D, getTriple(), SysRoot);
   bool IsKnownOs = (getTriple().getOS() != llvm::Triple::UnknownOS);
@@ -499,7 +499,7 @@ void WebAssembly::addLibStdCXXIncludePaths(
   // to how we do it for libc++.
   const Driver &D = getDriver();
   std::string SysRoot = computeSysRoot();
-  std::string LibPath = SysRoot + "/include";
+  std::string LibPath = SysRoot + "/lib/include";
   const std::string MultiarchTriple =
       getMultiarchTriple(D, getTriple(), SysRoot);
   bool IsKnownOs = (getTriple().getOS() != llvm::Triple::UnknownOS);
diff --git a/clang/tools/driver/CMakeLists.txt b/clang/tools/driver/CMakeLists.txt
index d05b71db1..86719fa12 100644
--- a/clang/tools/driver/CMakeLists.txt
+++ b/clang/tools/driver/CMakeLists.txt
@@ -47,7 +47,7 @@ clang_target_link_libraries(clang
 if(WIN32 AND NOT CYGWIN)
   # Prevent versioning if the buildhost is targeting for Win32.
 else()
-  set_target_properties(clang PROPERTIES VERSION ${CLANG_EXECUTABLE_VERSION})
+  # set_target_properties(clang PROPERTIES VERSION ${CLANG_EXECUTABLE_VERSION})
 endif()
 
 # Support plugins.
diff --git a/llvm/runtimes/CMakeLists.txt b/llvm/runtimes/CMakeLists.txt
index 701d35c0a..787eb4850 100644
--- a/llvm/runtimes/CMakeLists.txt
+++ b/llvm/runtimes/CMakeLists.txt
@@ -85,7 +85,7 @@ function(builtin_default_target compiler_rt_path)
                            CMAKE_ARGS -DLLVM_LIBRARY_OUTPUT_INTDIR=${LLVM_LIBRARY_DIR}
                                       -DLLVM_RUNTIME_OUTPUT_INTDIR=${LLVM_TOOLS_BINARY_DIR}
                                       -DLLVM_DEFAULT_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
-                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default}
+                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=OFF
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
                                       ${COMMON_CMAKE_ARGS}
@@ -119,7 +119,7 @@ function(builtin_register_target compiler_rt_path target)
                            CMAKE_ARGS -DLLVM_LIBRARY_OUTPUT_INTDIR=${LLVM_LIBRARY_DIR}
                                       -DLLVM_RUNTIME_OUTPUT_INTDIR=${LLVM_TOOLS_BINARY_DIR}
                                       -DLLVM_DEFAULT_TARGET_TRIPLE=${target}
-                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON
+                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=OFF
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
                                       -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
@@ -237,7 +237,7 @@ function(runtime_default_target)
                                       -DLLVM_INCLUDE_TESTS=${LLVM_INCLUDE_TESTS}
                                       -DLLVM_DEFAULT_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       -DLLVM_ENABLE_PROJECTS_USED=${LLVM_ENABLE_PROJECTS_USED}
-                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default}
+                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=OFF
                                       -DLLVM_BUILD_TOOLS=${LLVM_BUILD_TOOLS}
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_CXX_COMPILER_WORKS=ON
@@ -342,7 +342,7 @@ function(runtime_register_target name target)
                                       -DLLVM_INCLUDE_TESTS=${LLVM_INCLUDE_TESTS}
                                       -DLLVM_DEFAULT_TARGET_TRIPLE=${target}
                                       -DLLVM_ENABLE_PROJECTS_USED=${LLVM_ENABLE_PROJECTS_USED}
-                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON
+                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=OFF
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_CXX_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
