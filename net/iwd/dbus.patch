The patch below is extracted from the excellent work of Dylan Araps who
maintains a non-dbus fork of iwd at https://github.com/dylanaraps/eiwd

diff --git a/Makefile.am b/Makefile.am
index 768685f..0ea222e 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -193,7 +193,6 @@ src_iwd_SOURCES = src/main.c linux/nl80211.h src/iwd.h src/missing.h \
 					src/device.c \
 					src/station.h src/station.c \
 					src/ie.h src/ie.c \
-					src/dbus.h src/dbus.c \
 					src/mpdu.h src/mpdu.c \
 					src/eapol.h src/eapol.c \
 					src/eapolutil.h src/eapolutil.c \
@@ -231,6 +230,10 @@ src_iwd_SOURCES = src/main.c linux/nl80211.h src/iwd.h src/missing.h \
 					$(eap_sources) \
 					$(builtin_sources)
 
+if DBUS
+src_iwd_SOURCES += src/dbus.h src/dbus.c
+endif
+
 src_iwd_LDADD = $(ell_ldadd) -ldl
 src_iwd_DEPENDENCIES = $(ell_dependencies)
 
@@ -534,6 +537,10 @@ AM_CFLAGS = $(ell_cflags) -fvisibility=hidden \
 				-DUNITDIR=\""$(top_srcdir)/unit/"\" \
 				-DCERTDIR=\""$(top_builddir)/unit/"\"
 
+if DBUS
+AM_CFLAGS += -DHAVE_DBUS
+endif
+
 if MAINTAINER_MODE
 AM_CFLAGS += -DHAVE_PKCS8_SUPPORT
 endif
diff --git a/Makefile.in b/Makefile.in
index 668eaa9..33e7327 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -95,34 +95,36 @@ libexec_PROGRAMS = $(am__EXEEXT_4) $(am__EXEEXT_5)
 noinst_PROGRAMS = tools/probe-req$(EXEEXT) $(am__EXEEXT_6) \
 	$(am__EXEEXT_9)
 @DAEMON_TRUE@am__append_1 = src/iwd
-@DAEMON_TRUE@@SIM_HARDCODED_TRUE@am__append_2 = sim_hardcoded
-@DAEMON_TRUE@@SIM_HARDCODED_TRUE@am__append_3 = plugins/sim_hardcoded.c
-@DAEMON_TRUE@@OFONO_TRUE@am__append_4 = ofono
-@DAEMON_TRUE@@OFONO_TRUE@am__append_5 = plugins/ofono.c
-@DAEMON_TRUE@@DBUS_POLICY_TRUE@am__append_6 = src/iwd-dbus.conf
-@DAEMON_TRUE@@SYSTEMD_SERVICE_TRUE@am__append_7 = src/iwd.service
+@DAEMON_TRUE@@DBUS_TRUE@am__append_2 = src/dbus.h src/dbus.c
+@DAEMON_TRUE@@SIM_HARDCODED_TRUE@am__append_3 = sim_hardcoded
+@DAEMON_TRUE@@SIM_HARDCODED_TRUE@am__append_4 = plugins/sim_hardcoded.c
+@DAEMON_TRUE@@OFONO_TRUE@am__append_5 = ofono
+@DAEMON_TRUE@@OFONO_TRUE@am__append_6 = plugins/ofono.c
+@DAEMON_TRUE@@DBUS_POLICY_TRUE@am__append_7 = src/iwd-dbus.conf
 @DAEMON_TRUE@@SYSTEMD_SERVICE_TRUE@am__append_8 = src/iwd.service
-@DAEMON_TRUE@@SYSTEMD_SERVICE_TRUE@am__append_9 = src/net.connman.iwd.service
-@DAEMON_TRUE@@SYSTEMD_SERVICE_TRUE@am__append_10 = src/80-iwd.link
-@DAEMON_TRUE@@MANUAL_PAGES_TRUE@am__append_11 = src/iwd.8 src/iwd.debug.7 src/iwd.config.5 src/iwd.network.5
-@CLIENT_TRUE@am__append_12 = client/iwctl
-@CLIENT_TRUE@@MANUAL_PAGES_TRUE@am__append_13 = client/iwctl.1
-@MONITOR_TRUE@am__append_14 = monitor/iwmon
-@MANUAL_PAGES_TRUE@@MONITOR_TRUE@am__append_15 = monitor/iwmon.1
-@WIRED_TRUE@am__append_16 = wired/ead
-@DBUS_POLICY_TRUE@@WIRED_TRUE@am__append_17 = wired/ead-dbus.conf
-@SYSTEMD_SERVICE_TRUE@@WIRED_TRUE@am__append_18 = wired/ead.service
+@DAEMON_TRUE@@SYSTEMD_SERVICE_TRUE@am__append_9 = src/iwd.service
+@DAEMON_TRUE@@SYSTEMD_SERVICE_TRUE@am__append_10 = src/net.connman.iwd.service
+@DAEMON_TRUE@@SYSTEMD_SERVICE_TRUE@am__append_11 = src/80-iwd.link
+@DAEMON_TRUE@@MANUAL_PAGES_TRUE@am__append_12 = src/iwd.8 src/iwd.debug.7 src/iwd.config.5 src/iwd.network.5
+@CLIENT_TRUE@am__append_13 = client/iwctl
+@CLIENT_TRUE@@MANUAL_PAGES_TRUE@am__append_14 = client/iwctl.1
+@MONITOR_TRUE@am__append_15 = monitor/iwmon
+@MANUAL_PAGES_TRUE@@MONITOR_TRUE@am__append_16 = monitor/iwmon.1
+@WIRED_TRUE@am__append_17 = wired/ead
+@DBUS_POLICY_TRUE@@WIRED_TRUE@am__append_18 = wired/ead-dbus.conf
 @SYSTEMD_SERVICE_TRUE@@WIRED_TRUE@am__append_19 = wired/ead.service
-@SYSTEMD_SERVICE_TRUE@@WIRED_TRUE@am__append_20 = wired/net.connman.ead.service
-@MANUAL_PAGES_TRUE@@WIRED_TRUE@am__append_21 = wired/ead.8
-@HWSIM_TRUE@am__append_22 = tools/hwsim
-@DBUS_POLICY_TRUE@@HWSIM_TRUE@am__append_23 = tools/hwsim-dbus.conf
-@HWSIM_TRUE@@MANUAL_PAGES_TRUE@am__append_24 = tools/hwsim.1
-@TOOLS_TRUE@am__append_25 = tools/test-runner
-@CLIENT_TRUE@am__append_26 = unit/test-client
-@MAINTAINER_MODE_TRUE@am__append_27 = $(unit_tests)
+@SYSTEMD_SERVICE_TRUE@@WIRED_TRUE@am__append_20 = wired/ead.service
+@SYSTEMD_SERVICE_TRUE@@WIRED_TRUE@am__append_21 = wired/net.connman.ead.service
+@MANUAL_PAGES_TRUE@@WIRED_TRUE@am__append_22 = wired/ead.8
+@HWSIM_TRUE@am__append_23 = tools/hwsim
+@DBUS_POLICY_TRUE@@HWSIM_TRUE@am__append_24 = tools/hwsim-dbus.conf
+@HWSIM_TRUE@@MANUAL_PAGES_TRUE@am__append_25 = tools/hwsim.1
+@TOOLS_TRUE@am__append_26 = tools/test-runner
+@CLIENT_TRUE@am__append_27 = unit/test-client
+@MAINTAINER_MODE_TRUE@am__append_28 = $(unit_tests)
 TESTS = $(am__EXEEXT_8)
-@MAINTAINER_MODE_TRUE@am__append_28 = -DHAVE_PKCS8_SUPPORT
+@DBUS_TRUE@am__append_29 = -DHAVE_DBUS
+@MAINTAINER_MODE_TRUE@am__append_30 = -DHAVE_PKCS8_SUPPORT
 subdir = .
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/build-aux/libtool.m4 \
@@ -271,16 +273,15 @@ monitor_iwmon_OBJECTS = $(am_monitor_iwmon_OBJECTS)
 am__src_iwd_SOURCES_DIST = src/main.c linux/nl80211.h src/iwd.h \
 	src/missing.h src/plugin.h src/plugin.c src/netdev.h \
 	src/netdev.c src/wiphy.h src/wiphy.c src/device.c \
-	src/station.h src/station.c src/ie.h src/ie.c src/dbus.h \
-	src/dbus.c src/mpdu.h src/mpdu.c src/eapol.h src/eapol.c \
-	src/eapolutil.h src/eapolutil.c src/handshake.h \
-	src/handshake.c src/scan.h src/scan.c src/common.h \
-	src/common.c src/agent.h src/agent.c src/storage.h \
-	src/storage.c src/network.h src/network.c src/wsc.h src/wsc.c \
-	src/backtrace.h src/backtrace.c src/knownnetworks.h \
-	src/knownnetworks.c src/rfkill.h src/rfkill.c src/ft.h \
-	src/ft.c src/ap.c src/adhoc.c src/sae.h src/sae.c \
-	src/nl80211util.h src/nl80211util.c src/nl80211cmd.h \
+	src/station.h src/station.c src/ie.h src/ie.c src/mpdu.h \
+	src/mpdu.c src/eapol.h src/eapol.c src/eapolutil.h \
+	src/eapolutil.c src/handshake.h src/handshake.c src/scan.h \
+	src/scan.c src/common.h src/common.c src/agent.h src/agent.c \
+	src/storage.h src/storage.c src/network.h src/network.c \
+	src/wsc.h src/wsc.c src/backtrace.h src/backtrace.c \
+	src/knownnetworks.h src/knownnetworks.c src/rfkill.h \
+	src/rfkill.c src/ft.h src/ft.c src/ap.c src/adhoc.c src/sae.h \
+	src/sae.c src/nl80211util.h src/nl80211util.c src/nl80211cmd.h \
 	src/nl80211cmd.c src/owe.h src/owe.c src/blacklist.h \
 	src/blacklist.c src/manager.c src/erp.h src/erp.c src/fils.h \
 	src/fils.c src/auth-proto.h src/anqp.h src/anqp.c \
@@ -296,7 +297,7 @@ am__src_iwd_SOURCES_DIST = src/main.c linux/nl80211.h src/iwd.h \
 	src/simutil.c src/simauth.h src/simauth.c src/watchlist.h \
 	src/watchlist.c src/eap-tls-common.h src/eap-tls-common.c \
 	src/mschaputil.h src/mschaputil.c plugins/sim_hardcoded.c \
-	plugins/ofono.c
+	plugins/ofono.c src/dbus.h src/dbus.c
 am__objects_3 = src/eap.$(OBJEXT) src/eap-wsc.$(OBJEXT) \
 	src/eap-md5.$(OBJEXT) src/eap-tls.$(OBJEXT) \
 	src/eap-ttls.$(OBJEXT) src/eap-mschapv2.$(OBJEXT) \
@@ -309,16 +310,17 @@ am__objects_3 = src/eap.$(OBJEXT) src/eap-wsc.$(OBJEXT) \
 @DAEMON_TRUE@@SIM_HARDCODED_TRUE@am__objects_4 = plugins/sim_hardcoded.$(OBJEXT)
 @DAEMON_TRUE@@OFONO_TRUE@am__objects_5 = plugins/ofono.$(OBJEXT)
 am__objects_6 = $(am__objects_4) $(am__objects_5)
+@DAEMON_TRUE@@DBUS_TRUE@am__objects_7 = src/dbus.$(OBJEXT)
 @DAEMON_TRUE@am_src_iwd_OBJECTS = src/main.$(OBJEXT) \
 @DAEMON_TRUE@	src/plugin.$(OBJEXT) src/netdev.$(OBJEXT) \
 @DAEMON_TRUE@	src/wiphy.$(OBJEXT) src/device.$(OBJEXT) \
 @DAEMON_TRUE@	src/station.$(OBJEXT) src/ie.$(OBJEXT) \
-@DAEMON_TRUE@	src/dbus.$(OBJEXT) src/mpdu.$(OBJEXT) \
-@DAEMON_TRUE@	src/eapol.$(OBJEXT) src/eapolutil.$(OBJEXT) \
-@DAEMON_TRUE@	src/handshake.$(OBJEXT) src/scan.$(OBJEXT) \
-@DAEMON_TRUE@	src/common.$(OBJEXT) src/agent.$(OBJEXT) \
-@DAEMON_TRUE@	src/storage.$(OBJEXT) src/network.$(OBJEXT) \
-@DAEMON_TRUE@	src/wsc.$(OBJEXT) src/backtrace.$(OBJEXT) \
+@DAEMON_TRUE@	src/mpdu.$(OBJEXT) src/eapol.$(OBJEXT) \
+@DAEMON_TRUE@	src/eapolutil.$(OBJEXT) src/handshake.$(OBJEXT) \
+@DAEMON_TRUE@	src/scan.$(OBJEXT) src/common.$(OBJEXT) \
+@DAEMON_TRUE@	src/agent.$(OBJEXT) src/storage.$(OBJEXT) \
+@DAEMON_TRUE@	src/network.$(OBJEXT) src/wsc.$(OBJEXT) \
+@DAEMON_TRUE@	src/backtrace.$(OBJEXT) \
 @DAEMON_TRUE@	src/knownnetworks.$(OBJEXT) src/rfkill.$(OBJEXT) \
 @DAEMON_TRUE@	src/ft.$(OBJEXT) src/ap.$(OBJEXT) \
 @DAEMON_TRUE@	src/adhoc.$(OBJEXT) src/sae.$(OBJEXT) \
@@ -331,7 +333,7 @@ am__objects_6 = $(am__objects_4) $(am__objects_5)
 @DAEMON_TRUE@	src/hotspot.$(OBJEXT) src/p2putil.$(OBJEXT) \
 @DAEMON_TRUE@	src/module.$(OBJEXT) src/rrm.$(OBJEXT) \
 @DAEMON_TRUE@	src/frame-xchg.$(OBJEXT) $(am__objects_3) \
-@DAEMON_TRUE@	$(am__objects_6)
+@DAEMON_TRUE@	$(am__objects_6) $(am__objects_7)
 src_iwd_OBJECTS = $(am_src_iwd_OBJECTS)
 am__tools_hwsim_SOURCES_DIST = tools/hwsim.c src/mpdu.h src/util.h \
 	src/util.c src/storage.h src/storage.c src/common.h \
@@ -1021,8 +1023,8 @@ top_srcdir = @top_srcdir@
 wired_storagedir = @wired_storagedir@
 AM_MAKEFLAGS = --no-print-directory
 ACLOCAL_AMFLAGS = -I build-aux
-builtin_modules = $(am__append_2) $(am__append_4)
-builtin_sources = $(am__append_3) $(am__append_5)
+builtin_modules = $(am__append_3) $(am__append_5)
+builtin_sources = $(am__append_4) $(am__append_6)
 @EXTERNAL_ELL_FALSE@ell_cflags = 
 @EXTERNAL_ELL_TRUE@ell_cflags = @ELL_CFLAGS@
 @EXTERNAL_ELL_FALSE@ell_ldadd = ell/libell-internal.la
@@ -1145,20 +1147,21 @@ builtin_sources = $(am__append_3) $(am__append_5)
 
 @EXTERNAL_ELL_FALSE@ell_libell_internal_la_SOURCES = $(ell_headers) $(ell_sources)
 @DBUS_POLICY_TRUE@dbus_datadir = @DBUS_DATADIR@/dbus-1/system.d
-@DBUS_POLICY_TRUE@dist_dbus_data_DATA = $(am__append_6) \
-@DBUS_POLICY_TRUE@	$(am__append_17) $(am__append_23)
+@DBUS_POLICY_TRUE@dist_dbus_data_DATA = $(am__append_7) \
+@DBUS_POLICY_TRUE@	$(am__append_18) $(am__append_24)
 @SYSTEMD_SERVICE_TRUE@systemd_unitdir = @SYSTEMD_UNITDIR@
-@SYSTEMD_SERVICE_TRUE@systemd_unit_DATA = $(am__append_8) \
-@SYSTEMD_SERVICE_TRUE@	$(am__append_19)
+@SYSTEMD_SERVICE_TRUE@systemd_unit_DATA = $(am__append_9) \
+@SYSTEMD_SERVICE_TRUE@	$(am__append_20)
 @SYSTEMD_SERVICE_TRUE@dbus_busdir = @DBUS_BUSDIR@
-@SYSTEMD_SERVICE_TRUE@dbus_bus_DATA = $(am__append_9) $(am__append_20)
+@SYSTEMD_SERVICE_TRUE@dbus_bus_DATA = $(am__append_10) \
+@SYSTEMD_SERVICE_TRUE@	$(am__append_21)
 @SYSTEMD_SERVICE_TRUE@systemd_networkdir = @SYSTEMD_NETWORKDIR@
-@SYSTEMD_SERVICE_TRUE@systemd_network_DATA = $(am__append_10)
+@SYSTEMD_SERVICE_TRUE@systemd_network_DATA = $(am__append_11)
 @SYSTEMD_SERVICE_TRUE@systemd_modloaddir = @SYSTEMD_MODLOADDIR@
 @SYSTEMD_SERVICE_TRUE@systemd_modload_DATA = src/pkcs8.conf
-@MANUAL_PAGES_TRUE@man_MANS = $(am__append_11) $(am__append_13) \
-@MANUAL_PAGES_TRUE@	$(am__append_15) $(am__append_21) \
-@MANUAL_PAGES_TRUE@	$(am__append_24)
+@MANUAL_PAGES_TRUE@man_MANS = $(am__append_12) $(am__append_14) \
+@MANUAL_PAGES_TRUE@	$(am__append_16) $(am__append_22) \
+@MANUAL_PAGES_TRUE@	$(am__append_25)
 manual_pages = src/iwd.8 src/iwd.debug.7 src/iwd.config.5 src/iwd.network.5 \
 		client/iwctl.1 monitor/iwmon.1 wired/ead.8 tools/hwsim.1
 
@@ -1182,54 +1185,34 @@ eap_sources = src/eap.c src/eap.h src/eap-private.h \
 				src/eap-tls-common.h src/eap-tls-common.c \
 				src/mschaputil.h src/mschaputil.c
 
-@DAEMON_TRUE@src_iwd_SOURCES = src/main.c linux/nl80211.h src/iwd.h src/missing.h \
-@DAEMON_TRUE@					src/plugin.h src/plugin.c \
-@DAEMON_TRUE@					src/netdev.h src/netdev.c \
-@DAEMON_TRUE@					src/wiphy.h src/wiphy.c \
-@DAEMON_TRUE@					src/device.c \
-@DAEMON_TRUE@					src/station.h src/station.c \
-@DAEMON_TRUE@					src/ie.h src/ie.c \
-@DAEMON_TRUE@					src/dbus.h src/dbus.c \
-@DAEMON_TRUE@					src/mpdu.h src/mpdu.c \
-@DAEMON_TRUE@					src/eapol.h src/eapol.c \
-@DAEMON_TRUE@					src/eapolutil.h src/eapolutil.c \
-@DAEMON_TRUE@					src/handshake.h src/handshake.c \
-@DAEMON_TRUE@					src/scan.h src/scan.c \
-@DAEMON_TRUE@					src/common.h src/common.c \
-@DAEMON_TRUE@					src/agent.h src/agent.c \
-@DAEMON_TRUE@					src/storage.h src/storage.c \
-@DAEMON_TRUE@					src/network.h src/network.c \
-@DAEMON_TRUE@					src/wsc.h src/wsc.c \
-@DAEMON_TRUE@					src/backtrace.h src/backtrace.c \
-@DAEMON_TRUE@					src/knownnetworks.h \
-@DAEMON_TRUE@					src/knownnetworks.c \
-@DAEMON_TRUE@					src/rfkill.h src/rfkill.c \
-@DAEMON_TRUE@					src/ft.h src/ft.c \
-@DAEMON_TRUE@					src/ap.c src/adhoc.c \
-@DAEMON_TRUE@					src/sae.h src/sae.c \
-@DAEMON_TRUE@					src/nl80211util.h src/nl80211util.c \
-@DAEMON_TRUE@					src/nl80211cmd.h src/nl80211cmd.c \
-@DAEMON_TRUE@					src/owe.h src/owe.c \
-@DAEMON_TRUE@					src/blacklist.h src/blacklist.c \
-@DAEMON_TRUE@					src/manager.c \
-@DAEMON_TRUE@					src/erp.h src/erp.c \
-@DAEMON_TRUE@					src/fils.h src/fils.c \
-@DAEMON_TRUE@					src/auth-proto.h \
-@DAEMON_TRUE@					src/anqp.h src/anqp.c \
-@DAEMON_TRUE@					src/anqputil.h src/anqputil.c \
-@DAEMON_TRUE@					src/netconfig.h src/netconfig.c\
-@DAEMON_TRUE@					src/resolve.h src/resolve.c\
-@DAEMON_TRUE@					src/hotspot.c \
-@DAEMON_TRUE@					src/p2putil.h src/p2putil.c \
-@DAEMON_TRUE@					src/module.h src/module.c \
-@DAEMON_TRUE@					src/rrm.c \
-@DAEMON_TRUE@					src/frame-xchg.h src/frame-xchg.c \
-@DAEMON_TRUE@					$(eap_sources) \
-@DAEMON_TRUE@					$(builtin_sources)
-
+@DAEMON_TRUE@src_iwd_SOURCES = src/main.c linux/nl80211.h src/iwd.h \
+@DAEMON_TRUE@	src/missing.h src/plugin.h src/plugin.c \
+@DAEMON_TRUE@	src/netdev.h src/netdev.c src/wiphy.h src/wiphy.c \
+@DAEMON_TRUE@	src/device.c src/station.h src/station.c src/ie.h \
+@DAEMON_TRUE@	src/ie.c src/mpdu.h src/mpdu.c src/eapol.h \
+@DAEMON_TRUE@	src/eapol.c src/eapolutil.h src/eapolutil.c \
+@DAEMON_TRUE@	src/handshake.h src/handshake.c src/scan.h \
+@DAEMON_TRUE@	src/scan.c src/common.h src/common.c src/agent.h \
+@DAEMON_TRUE@	src/agent.c src/storage.h src/storage.c \
+@DAEMON_TRUE@	src/network.h src/network.c src/wsc.h src/wsc.c \
+@DAEMON_TRUE@	src/backtrace.h src/backtrace.c \
+@DAEMON_TRUE@	src/knownnetworks.h src/knownnetworks.c \
+@DAEMON_TRUE@	src/rfkill.h src/rfkill.c src/ft.h src/ft.c \
+@DAEMON_TRUE@	src/ap.c src/adhoc.c src/sae.h src/sae.c \
+@DAEMON_TRUE@	src/nl80211util.h src/nl80211util.c \
+@DAEMON_TRUE@	src/nl80211cmd.h src/nl80211cmd.c src/owe.h \
+@DAEMON_TRUE@	src/owe.c src/blacklist.h src/blacklist.c \
+@DAEMON_TRUE@	src/manager.c src/erp.h src/erp.c src/fils.h \
+@DAEMON_TRUE@	src/fils.c src/auth-proto.h src/anqp.h src/anqp.c \
+@DAEMON_TRUE@	src/anqputil.h src/anqputil.c src/netconfig.h \
+@DAEMON_TRUE@	src/netconfig.c src/resolve.h src/resolve.c \
+@DAEMON_TRUE@	src/hotspot.c src/p2putil.h src/p2putil.c \
+@DAEMON_TRUE@	src/module.h src/module.c src/rrm.c \
+@DAEMON_TRUE@	src/frame-xchg.h src/frame-xchg.c $(eap_sources) \
+@DAEMON_TRUE@	$(builtin_sources) $(am__append_2)
 @DAEMON_TRUE@src_iwd_LDADD = $(ell_ldadd) -ldl
 @DAEMON_TRUE@src_iwd_DEPENDENCIES = $(ell_dependencies) \
-@DAEMON_TRUE@	$(am__append_7)
+@DAEMON_TRUE@	$(am__append_8)
 @CLIENT_TRUE@client_iwctl_SOURCES = client/main.c \
 @CLIENT_TRUE@			client/adapter.c \
 @CLIENT_TRUE@			client/agent.h client/agent.c \
@@ -1271,7 +1254,7 @@ eap_sources = src/eap.c src/eap.h src/eap-private.h \
 
 @WIRED_TRUE@wired_ead_LDADD = $(ell_ldadd)
 @WIRED_TRUE@wired_ead_DEPENDENCIES = $(ell_dependencies) \
-@WIRED_TRUE@	$(am__append_18)
+@WIRED_TRUE@	$(am__append_19)
 tools_probe_req_SOURCES = tools/probe-req.c src/mpdu.h src/mpdu.c \
 					src/ie.h src/ie.c \
 					src/nl80211util.h src/nl80211util.c \
@@ -1292,7 +1275,7 @@ unit_tests = unit/test-cmac-aes unit/test-hmac-md5 unit/test-hmac-sha1 \
 	unit/test-crypto unit/test-eapol unit/test-mpdu unit/test-ie \
 	unit/test-util unit/test-ssid-security unit/test-arc4 \
 	unit/test-wsc unit/test-eap-mschapv2 unit/test-eap-sim \
-	unit/test-sae unit/test-p2p $(am__append_26)
+	unit/test-sae unit/test-p2p $(am__append_27)
 unit_test_eap_sim_SOURCES = unit/test-eap-sim.c \
 		src/crypto.h src/crypto.c src/simutil.h src/simutil.c \
 		src/ie.h src/ie.c \
@@ -1431,7 +1414,8 @@ EXTRA_DIST = src/genbuiltin src/iwd.service.in src/net.connman.iwd.service \
 
 AM_CFLAGS = $(ell_cflags) -fvisibility=hidden \
 	-DUNITDIR=\""$(top_srcdir)/unit/"\" \
-	-DCERTDIR=\""$(top_builddir)/unit/"\" $(am__append_28)
+	-DCERTDIR=\""$(top_builddir)/unit/"\" $(am__append_29) \
+	$(am__append_30)
 CLEANFILES = src/iwd.service wired/ead.service
 DISTCHECK_CONFIGURE_FLAGS = --disable-dbus-policy --disable-systemd-service \
 				--enable-sim-hardcoded \
@@ -1787,7 +1771,6 @@ src/device.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
 src/station.$(OBJEXT): src/$(am__dirstamp) \
 	src/$(DEPDIR)/$(am__dirstamp)
-src/dbus.$(OBJEXT): src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
 src/eapol.$(OBJEXT): src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
 src/scan.$(OBJEXT): src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
 src/common.$(OBJEXT): src/$(am__dirstamp) \
@@ -1868,6 +1851,7 @@ plugins/sim_hardcoded.$(OBJEXT): plugins/$(am__dirstamp) \
 	plugins/$(DEPDIR)/$(am__dirstamp)
 plugins/ofono.$(OBJEXT): plugins/$(am__dirstamp) \
 	plugins/$(DEPDIR)/$(am__dirstamp)
+src/dbus.$(OBJEXT): src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
 
 src/iwd$(EXEEXT): $(src_iwd_OBJECTS) $(src_iwd_DEPENDENCIES) $(EXTRA_src_iwd_DEPENDENCIES) src/$(am__dirstamp)
 	@rm -f src/iwd$(EXEEXT)
diff --git a/configure b/configure
index bbefbd7..c515838 100755
--- a/configure
+++ b/configure
@@ -665,6 +665,8 @@ MONITOR_FALSE
 MONITOR_TRUE
 CLIENT_FALSE
 CLIENT_TRUE
+DBUS_FALSE
+DBUS_TRUE
 DAEMON_FALSE
 DAEMON_TRUE
 wired_storagedir
@@ -811,6 +813,7 @@ enable_asan
 enable_lsan
 enable_ubsan
 enable_daemon
+enable_dbus
 enable_client
 enable_monitor
 enable_dbus_policy
@@ -1494,6 +1497,7 @@ Optional Features:
   --enable-lsan           enable linking with leak sanitizer
   --enable-ubsan          enable linking with undefined behavior sanitizer
   --disable-daemon        don't install iwd system daemon
+  --disable-dbus          disable dbus in daemon
   --disable-client        don't install iwctl client utility
   --disable-monitor       don't install iwmon monitor utility
   --disable-dbus-policy   don't install D-Bus system policy files
@@ -13017,12 +13021,26 @@ else
 fi
 
 
+# Check whether --enable-dbus was given.
+if test "${enable_dbus+set}" = set; then :
+  enableval=$enable_dbus; disable_dbus=${enableval}
+fi
+
+ if test "${disable_dbus}" != "no"; then
+  DBUS_TRUE=
+  DBUS_FALSE='#'
+else
+  DBUS_TRUE='#'
+  DBUS_FALSE=
+fi
+
+
 # Check whether --enable-client was given.
 if test "${enable_client+set}" = set; then :
   enableval=$enable_client; enable_client=${enableval}
 fi
 
-if (test "${enable_client}" != "no"); then
+if (test "${enable_client}" != "no" && test "${disable_dbus}" != "no"); then
 	for ac_header in readline/readline.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "readline/readline.h" "ac_cv_header_readline_readline_h" "$ac_includes_default"
@@ -13038,7 +13056,7 @@ fi
 done
 
 fi
- if test "${enable_client}" != "no"; then
+ if test "${enable_client}" != "no" && test "${disable_dbus}" != "no"; then
   CLIENT_TRUE=
   CLIENT_FALSE='#'
 else
@@ -13066,7 +13084,7 @@ if test "${enable_dbus_policy+set}" = set; then :
   enableval=$enable_dbus_policy; enable_dbus_policy=${enableval}
 fi
 
- if test "${enable_dbus_policy}" != "no"; then
+ if test "${enable_dbus_policy}" != "no" && test "${disable_dbus}" != "no"; then
   DBUS_POLICY_TRUE=
   DBUS_POLICY_FALSE='#'
 else
@@ -13081,7 +13099,7 @@ if test "${with_dbus_datadir+set}" = set; then :
   withval=$with_dbus_datadir; path_dbus_datadir=${withval}
 fi
 
-if (test "${enable_dbus_policy}" != "no" && test -z "${path_dbus_datadir}"); then
+if (test "${enable_dbus_policy}" != "no" && test -z "${path_dbus_datadir}" && test "${disable_dbus}" != "no"); then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking D-Bus data directory" >&5
 $as_echo_n "checking D-Bus data directory... " >&6; }
 	path_dbus_datadir="`$PKG_CONFIG --variable=datadir dbus-1`"
@@ -13102,7 +13120,7 @@ if test "${enable_systemd_service+set}" = set; then :
   enableval=$enable_systemd_service; enable_systemd_service=${enableval}
 fi
 
- if test "${enable_systemd_service}" != "no"; then
+ if test "${enable_systemd_service}" != "no" && test "${disable_dbus}" != "no" && test "${disable_dbus}" != "no"; then
   SYSTEMD_SERVICE_TRUE=
   SYSTEMD_SERVICE_FALSE='#'
 else
@@ -13184,7 +13202,7 @@ if test "${with_dbus_busdir+set}" = set; then :
   withval=$with_dbus_busdir; path_dbus_busdir=${withval}
 fi
 
-if (test "${enable_systemd_service}" != "no" && test -z "${path_dbus_busdir}"); then
+if (test "${enable_systemd_service}" != "no" && test -z "${path_dbus_busdir}" && test "${disable_dbus}" != "no"); then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking D-Bus bus services directory" >&5
 $as_echo_n "checking D-Bus bus services directory... " >&6; }
 	path_dbus_busdir="`$PKG_CONFIG --variable=system_bus_services_dir dbus-1`"
@@ -13203,7 +13221,7 @@ if test "${with_systemd_unitdir+set}" = set; then :
   withval=$with_systemd_unitdir; path_systemd_unitdir=${withval}
 fi
 
-if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_unitdir}"); then
+if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_unitdir}" && test "${disable_dbus}" != "no"); then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking systemd unit directory" >&5
 $as_echo_n "checking systemd unit directory... " >&6; }
 	path_systemd_unitdir="`$PKG_CONFIG --variable=systemdsystemunitdir systemd`"
@@ -13222,7 +13240,7 @@ if test "${with_systemd_networkdir+set}" = set; then :
   withval=$with_systemd_networkdir; path_systemd_networkdir=${withval}
 fi
 
-if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_networkdir}"); then
+if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_networkdir}" && test "${disable_dbus}" != "no"); then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking systemd network directory" >&5
 $as_echo_n "checking systemd network directory... " >&6; }
 	path_systemd_networkdir="`$PKG_CONFIG --variable=systemdutildir systemd`"
@@ -13242,7 +13260,7 @@ if test "${with_systemd_modloaddir+set}" = set; then :
   withval=$with_systemd_modloaddir; path_systemd_modloaddir=${withval}
 fi
 
-if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_modloaddir}"); then
+if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_modloaddir}" && test "${disable_dbus}" != "no"); then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking systemd modules load directory" >&5
 $as_echo_n "checking systemd modules load directory... " >&6; }
 	path_systemd_modloaddir="`$PKG_CONFIG --variable=modulesloaddir systemd`"
@@ -13359,7 +13377,7 @@ if test "${enable_wired+set}" = set; then :
   enableval=$enable_wired; enable_wired=${enableval}
 fi
 
- if test "${enable_wired}" = "yes"; then
+ if test "${enable_wired}" = "yes" && test "${disable_dbus}" != "no"; then
   WIRED_TRUE=
   WIRED_FALSE='#'
 else
@@ -13373,7 +13391,7 @@ if test "${enable_hwsim+set}" = set; then :
   enableval=$enable_hwsim; enable_hwsim=${enableval}
 fi
 
- if test "${enable_hwsim}" = "yes"; then
+ if test "${enable_hwsim}" = "yes" && test "${disable_dbus}" != "no"; then
   HWSIM_TRUE=
   HWSIM_FALSE='#'
 else
@@ -13387,7 +13405,7 @@ if test "${enable_tools+set}" = set; then :
   enableval=$enable_tools; enable_tools=${enableval}
 fi
 
- if test "${enable_tools}" = "yes"; then
+ if test "${enable_tools}" = "yes" && test "${disable_dbus}" != "no"; then
   TOOLS_TRUE=
   TOOLS_FALSE='#'
 else
@@ -13401,7 +13419,7 @@ if test "${enable_ofono+set}" = set; then :
   enableval=$enable_ofono; enable_ofono=${enableval}
 fi
 
- if test "${enable_ofono}" = "yes"; then
+ if test "${enable_ofono}" = "yes" && test "${disable_dbus}" != "no"; then
   OFONO_TRUE=
   OFONO_FALSE='#'
 else
@@ -13415,7 +13433,7 @@ if test "${enable_sim_hardcoded+set}" = set; then :
   enableval=$enable_sim_hardcoded; enable_sim_hardcoded=${enableval}
 fi
 
- if test "${enable_sim_hardcoded}" = "yes"; then
+ if test "${enable_sim_hardcoded}" = "yes" && test "${disable_dbus}" != "no"; then
   SIM_HARDCODED_TRUE=
   SIM_HARDCODED_FALSE='#'
 else
@@ -13568,6 +13586,10 @@ if test -z "${DAEMON_TRUE}" && test -z "${DAEMON_FALSE}"; then
   as_fn_error $? "conditional \"DAEMON\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${DBUS_TRUE}" && test -z "${DBUS_FALSE}"; then
+  as_fn_error $? "conditional \"DBUS\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${CLIENT_TRUE}" && test -z "${CLIENT_FALSE}"; then
   as_fn_error $? "conditional \"CLIENT\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
diff --git a/configure.ac b/configure.ac
index ddbc287..e93d369 100644
--- a/configure.ac
+++ b/configure.ac
@@ -148,14 +148,19 @@ AC_ARG_ENABLE([daemon], AC_HELP_STRING([--disable-daemon],
 					[enable_daemon=${enableval}])
 AM_CONDITIONAL(DAEMON, test "${enable_daemon}" != "no")
 
+AC_ARG_ENABLE([dbus], AC_HELP_STRING([--disable-dbus],
+				[disable dbus in daemon]),
+					[disable_dbus=${enableval}])
+AM_CONDITIONAL(DBUS, test "${disable_dbus}" != "no")
+
 AC_ARG_ENABLE([client], AC_HELP_STRING([--disable-client],
 				[don't install iwctl client utility]),
 					[enable_client=${enableval}])
-if (test "${enable_client}" != "no"); then
+if (test "${enable_client}" != "no" && test "${disable_dbus}" != "no"); then
 	AC_CHECK_HEADERS(readline/readline.h, enable_readline=yes,
 			AC_MSG_ERROR(readline header files are required))
 fi
-AM_CONDITIONAL(CLIENT, test "${enable_client}" != "no")
+AM_CONDITIONAL(CLIENT, test "${enable_client}" != "no" && test "${disable_dbus}" != "no")
 
 AC_ARG_ENABLE([monitor], AC_HELP_STRING([--disable-monitor],
 				[don't install iwmon monitor utility]),
@@ -165,12 +170,12 @@ AM_CONDITIONAL(MONITOR, test "${enable_monitor}" != "no")
 AC_ARG_ENABLE([dbus-policy], AC_HELP_STRING([--disable-dbus-policy],
 				[don't install D-Bus system policy files]),
 					[enable_dbus_policy=${enableval}])
-AM_CONDITIONAL(DBUS_POLICY, test "${enable_dbus_policy}" != "no")
+AM_CONDITIONAL(DBUS_POLICY, test "${enable_dbus_policy}" != "no" && test "${disable_dbus}" != "no")
 
 AC_ARG_WITH([dbus-datadir], AC_HELP_STRING([--with-dbus-datadir=DIR],
 				[path to D-Bus data directory]),
 					[path_dbus_datadir=${withval}])
-if (test "${enable_dbus_policy}" != "no" && test -z "${path_dbus_datadir}"); then
+if (test "${enable_dbus_policy}" != "no" && test -z "${path_dbus_datadir}" && test "${disable_dbus}" != "no"); then
 	AC_MSG_CHECKING([D-Bus data directory])
 	path_dbus_datadir="`$PKG_CONFIG --variable=datadir dbus-1`"
 	if (test -z "${path_dbus_datadir}"); then
@@ -186,7 +191,7 @@ AC_SUBST(DBUS_DATADIR, [${path_dbus_datadir}])
 AC_ARG_ENABLE([systemd-service], AC_HELP_STRING([--disable-systemd-service],
 				[don't install systemd service files]),
 					[enable_systemd_service=${enableval}])
-AM_CONDITIONAL(SYSTEMD_SERVICE, test "${enable_systemd_service}" != "no")
+AM_CONDITIONAL(SYSTEMD_SERVICE, test "${enable_systemd_service}" != "no" && test "${disable_dbus}" != "no" && test "${disable_dbus}" != "no")
 
 AC_ARG_ENABLE([manual-pages], AC_HELP_STRING([--disable-manual-pages],
 				[don't install manual pages]),
@@ -200,7 +205,7 @@ AM_CONDITIONAL(RUN_RST2MAN, test "${enable_manual_pages}" != "no" && test "${RST
 AC_ARG_WITH([dbus-busdir], AC_HELP_STRING([--with-dbus-busdir=DIR],
 				[path to D-Bus bus services directory]),
 					[path_dbus_busdir=${withval}])
-if (test "${enable_systemd_service}" != "no" && test -z "${path_dbus_busdir}"); then
+if (test "${enable_systemd_service}" != "no" && test -z "${path_dbus_busdir}" && test "${disable_dbus}" != "no"); then
 	AC_MSG_CHECKING([D-Bus bus services directory])
 	path_dbus_busdir="`$PKG_CONFIG --variable=system_bus_services_dir dbus-1`"
 	if (test -z "${path_dbus_busdir}"); then
@@ -213,7 +218,7 @@ AC_SUBST(DBUS_BUSDIR, [${path_dbus_busdir}])
 AC_ARG_WITH([systemd-unitdir], AC_HELP_STRING([--with-systemd-unitdir=DIR],
 				[path to systemd unit directory]),
 					[path_systemd_unitdir=${withval}])
-if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_unitdir}"); then
+if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_unitdir}" && test "${disable_dbus}" != "no"); then
 	AC_MSG_CHECKING([systemd unit directory])
 	path_systemd_unitdir="`$PKG_CONFIG --variable=systemdsystemunitdir systemd`"
 	if (test -z "${path_systemd_unitdir}"); then
@@ -226,7 +231,7 @@ AC_SUBST(SYSTEMD_UNITDIR, [${path_systemd_unitdir}])
 AC_ARG_WITH([systemd-networkdir], AC_HELP_STRING([--with-systemd-networkdir=DIR],
 				[path to systemd network directory]),
 					[path_systemd_networkdir=${withval}])
-if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_networkdir}"); then
+if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_networkdir}" && test "${disable_dbus}" != "no"); then
 	AC_MSG_CHECKING([systemd network directory])
 	path_systemd_networkdir="`$PKG_CONFIG --variable=systemdutildir systemd`"
 	if (test -z "${path_systemd_networkdir}"); then
@@ -240,7 +245,7 @@ AC_SUBST(SYSTEMD_NETWORKDIR, [${path_systemd_networkdir}])
 AC_ARG_WITH([systemd-modloaddir], AC_HELP_STRING([--with-systemd-modloaddir=DIR],
 				[path to systemd modules load directory]),
 					[path_systemd_modloaddir=${withval}])
-if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_modloaddir}"); then
+if (test "${enable_systemd_service}" != "no" && test -z "${path_systemd_modloaddir}" && test "${disable_dbus}" != "no"); then
 	AC_MSG_CHECKING([systemd modules load directory])
 	path_systemd_modloaddir="`$PKG_CONFIG --variable=modulesloaddir systemd`"
 	if (test -z "${path_systemd_modloaddir}"); then
@@ -274,27 +279,27 @@ AM_CONDITIONAL(EXTERNAL_ELL, test "${enable_external_ell}" = "yes")
 AC_ARG_ENABLE([wired], AC_HELP_STRING([--enable-wired],
 				[enable Ethernet authentication support]),
 					[enable_wired=${enableval}])
-AM_CONDITIONAL(WIRED, test "${enable_wired}" = "yes")
+AM_CONDITIONAL(WIRED, test "${enable_wired}" = "yes" && test "${disable_dbus}" != "no")
 
 AC_ARG_ENABLE([hwsim], AC_HELP_STRING([--enable-hwsim],
 				[enable Wireless simulation utility]),
 					[enable_hwsim=${enableval}])
-AM_CONDITIONAL(HWSIM, test "${enable_hwsim}" = "yes")
+AM_CONDITIONAL(HWSIM, test "${enable_hwsim}" = "yes" && test "${disable_dbus}" != "no")
 
 AC_ARG_ENABLE([tools], AC_HELP_STRING([--enable-tools],
 				[enable internal testing utilities]),
 					[enable_tools=${enableval}])
-AM_CONDITIONAL(TOOLS, test "${enable_tools}" = "yes")
+AM_CONDITIONAL(TOOLS, test "${enable_tools}" = "yes" && test "${disable_dbus}" != "no")
 
 AC_ARG_ENABLE([ofono], AC_HELP_STRING([--enable-ofono],
 				[enable oFono SIM authentication support]),
 					[enable_ofono=${enableval}])
-AM_CONDITIONAL(OFONO, test "${enable_ofono}" = "yes")
+AM_CONDITIONAL(OFONO, test "${enable_ofono}" = "yes" && test "${disable_dbus}" != "no")
 
 AC_ARG_ENABLE([sim_hardcoded], AC_HELP_STRING([--enable-sim-hardcoded],
 				[enable hard coded SIM keys]),
 					[enable_sim_hardcoded=${enableval}])
-AM_CONDITIONAL(SIM_HARDCODED, test "${enable_sim_hardcoded}" = "yes")
+AM_CONDITIONAL(SIM_HARDCODED, test "${enable_sim_hardcoded}" = "yes" && test "${disable_dbus}" != "no")
 
 AC_CONFIG_FILES(Makefile)
 
diff --git a/src/adhoc.c b/src/adhoc.c
index 8a99548..707e459 100644
--- a/src/adhoc.c
+++ b/src/adhoc.c
@@ -41,7 +41,9 @@
 #include "src/eapol.h"
 #include "src/handshake.h"
 #include "src/mpdu.h"
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#endif
 #include "src/nl80211util.h"
 
 struct adhoc_state {
@@ -77,6 +79,7 @@ struct sta_state {
 
 static uint32_t netdev_watch;
 
+#ifdef HAVE_DBUS
 static void adhoc_sta_free(void *data)
 {
 	struct sta_state *sta = data;
@@ -210,9 +213,12 @@ static void adhoc_handshake_event(struct handshake_state *hs,
 		if ((sta->hs_auth_done && sta->hs_sta_done) &&
 				!sta->authenticated) {
 			sta->authenticated = true;
+
+#ifdef HAVE_DBUS
 			l_dbus_property_changed(dbus_get_bus(),
 					netdev_get_path(adhoc->netdev),
 					IWD_ADHOC_INTERFACE, "ConnectedPeers");
+#endif
 		}
 		break;
 	default:
@@ -420,9 +426,11 @@ static void adhoc_new_station(struct adhoc_state *adhoc, const uint8_t *mac)
 					adhoc_operstate_cb,
 					L_UINT_TO_PTR(ifindex), NULL);
 
+#ifdef HAVE_DBUS
 		l_dbus_property_changed(dbus_get_bus(),
 					netdev_get_path(adhoc->netdev),
 					IWD_ADHOC_INTERFACE, "ConnectedPeers");
+#endif
 		return;
 	}
 
@@ -473,27 +481,37 @@ static void adhoc_station_changed_cb(struct netdev *netdev,
 static void adhoc_join_cb(struct netdev *netdev, int result, void *user_data)
 {
 	struct adhoc_state *adhoc = user_data;
+
+#ifdef HAVE_DBUS
 	struct l_dbus_message *reply;
+#endif
 
 	if (result < 0) {
 		l_error("Failed to join adhoc network, %i", result);
+#ifdef HAVE_DBUS
 		dbus_pending_reply(&adhoc->pending,
 					dbus_error_failed(adhoc->pending));
+#endif
 		return;
 	}
 
 	adhoc->sta_watch_id = netdev_station_watch_add(netdev,
 			adhoc_station_changed_cb, adhoc);
 
+#ifdef HAVE_DBUS
 	reply = l_dbus_message_new_method_return(adhoc->pending);
 	dbus_pending_reply(&adhoc->pending, reply);
+#endif
 
 	adhoc->started = true;
 
+#ifdef HAVE_DBUS
 	l_dbus_property_changed(dbus_get_bus(), netdev_get_path(adhoc->netdev),
 						IWD_ADHOC_INTERFACE, "Started");
+#endif
 }
 
+#ifdef HAVE_DBUS
 static struct l_dbus_message *adhoc_dbus_start(struct l_dbus *dbus,
 						struct l_dbus_message *message,
 						void *user_data)
@@ -569,11 +587,13 @@ static struct l_dbus_message *adhoc_dbus_start_open(struct l_dbus *dbus,
 
 	return NULL;
 }
+#endif
 
 static void adhoc_leave_cb(struct netdev *netdev, int result, void *user_data)
 {
 	struct adhoc_state *adhoc = user_data;
 
+#ifdef HAVE_DBUS
 	if (result < 0) {
 		l_error("Failed to leave adhoc network, %i", result);
 		dbus_pending_reply(&adhoc->pending,
@@ -583,10 +603,12 @@ static void adhoc_leave_cb(struct netdev *netdev, int result, void *user_data)
 
 	dbus_pending_reply(&adhoc->pending,
 			l_dbus_message_new_method_return(adhoc->pending));
+#endif
 
 	adhoc_reset(adhoc);
 }
 
+#ifdef HAVE_DBUS
 static struct l_dbus_message *adhoc_dbus_stop(struct l_dbus *dbus,
 						struct l_dbus_message *message,
 						void *user_data)
@@ -663,6 +685,7 @@ static void adhoc_setup_interface(struct l_dbus_interface *interface)
 	l_dbus_interface_property(interface, "Started", 0, "b",
 					adhoc_property_get_started, NULL);
 }
+#endif
 
 static void adhoc_destroy_interface(void *user_data)
 {
@@ -670,6 +693,7 @@ static void adhoc_destroy_interface(void *user_data)
 
 	adhoc_free(adhoc);
 }
+#endif
 
 static void adhoc_add_interface(struct netdev *netdev)
 {
@@ -680,15 +704,19 @@ static void adhoc_add_interface(struct netdev *netdev)
 	adhoc->netdev = netdev;
 	adhoc->nl80211 = l_genl_family_new(iwd_get_genl(), NL80211_GENL_NAME);
 
+#ifdef HAVE_DBUS
 	/* setup adhoc dbus interface */
 	l_dbus_object_add_interface(dbus_get_bus(),
 			netdev_get_path(netdev), IWD_ADHOC_INTERFACE, adhoc);
+#endif
 }
 
 static void adhoc_remove_interface(struct netdev *netdev)
 {
+#ifdef HAVE_DBUS
 	l_dbus_object_remove_interface(dbus_get_bus(),
 			netdev_get_path(netdev), IWD_ADHOC_INTERFACE);
+#endif
 }
 
 static void adhoc_netdev_watch(struct netdev *netdev,
@@ -713,8 +741,11 @@ static void adhoc_netdev_watch(struct netdev *netdev,
 static int adhoc_init(void)
 {
 	netdev_watch = netdev_watch_add(adhoc_netdev_watch, NULL, NULL);
+
+#ifdef HAVE_DBUS
 	l_dbus_register_interface(dbus_get_bus(), IWD_ADHOC_INTERFACE,
 			adhoc_setup_interface, adhoc_destroy_interface, false);
+#endif
 
 	return 0;
 }
@@ -722,7 +753,10 @@ static int adhoc_init(void)
 static void adhoc_exit(void)
 {
 	netdev_watch_remove(netdev_watch);
+
+#ifdef HAVE_DBUS
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_ADHOC_INTERFACE);
+#endif
 }
 
 IWD_MODULE(adhoc, adhoc_init, adhoc_exit)
diff --git a/src/agent.c b/src/agent.c
index d213f3c..976dced 100644
--- a/src/agent.c
+++ b/src/agent.c
@@ -27,7 +27,9 @@
 #include <errno.h>
 
 #include <ell/ell.h>
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#endif
 #include "src/agent.h"
 #include "src/iwd.h"
 #include "src/module.h"
@@ -62,6 +64,7 @@ struct agent {
 
 static struct l_queue *agents;
 
+#ifdef HAVE_DBUS
 /*
  * How long we wait for user to input things.
  * Return value is in seconds.
@@ -128,11 +131,13 @@ static void send_cancel_request(void *user_data, int reason)
 
 	l_dbus_send(dbus_get_bus(), message);
 }
+#endif
 
 static void agent_request_free(void *user_data)
 {
 	struct agent_request *request = user_data;
 
+#ifdef HAVE_DBUS
 	l_dbus_message_unref(request->message);
 
 	if (request->trigger)
@@ -141,10 +146,12 @@ static void agent_request_free(void *user_data)
 
 	if (request->destroy)
 		request->destroy(request->user_data);
+#endif
 
 	l_free(request);
 }
 
+#ifdef HAVE_DBUS
 static void passphrase_reply(struct l_dbus_message *reply,
 					struct agent_request *request)
 {
@@ -187,6 +194,7 @@ done:
 	user_callback(result, username, passwd,
 			request->trigger, request->user_data);
 }
+#endif
 
 static void agent_finalize_pending(struct agent *agent,
 						struct l_dbus_message *reply)
@@ -202,17 +210,23 @@ static void agent_finalize_pending(struct agent *agent,
 
 	switch (pending->type) {
 	case AGENT_REQUEST_TYPE_PASSPHRASE:
+#ifdef HAVE_DBUS
 		passphrase_reply(reply, pending);
+#endif
 		break;
 	case AGENT_REQUEST_TYPE_USER_NAME_PASSWD:
+#ifdef HAVE_DBUS
 		user_name_passwd_reply(reply, pending);
+#endif
 		break;
 	}
 
+#ifdef HAVE_DBUS
 	if (pending->trigger) {
 		l_dbus_message_unref(pending->trigger);
 		pending->trigger = NULL;
 	}
+#endif
 
 	agent_request_free(pending);
 }
@@ -226,13 +240,17 @@ static void agent_free(void *data)
 	if (agent->timeout)
 		l_timeout_remove(agent->timeout);
 
+#ifdef HAVE_DBUS
 	if (agent->pending_id)
 		l_dbus_cancel(dbus_get_bus(), agent->pending_id);
+#endif
 
 	l_queue_destroy(agent->requests, agent_request_free);
 
+#ifdef HAVE_DBUS
 	if (agent->disconnect_watch)
 		l_dbus_remove_watch(dbus_get_bus(), agent->disconnect_watch);
+#endif
 
 	l_free(agent->owner);
 	l_free(agent->path);
@@ -245,15 +263,18 @@ static void request_timeout(struct l_timeout *timeout, void *user_data)
 {
 	struct agent *agent = user_data;
 
+#ifdef HAVE_DBUS
 	l_dbus_cancel(dbus_get_bus(), agent->pending_id);
 
 	send_cancel_request(agent, -ETIMEDOUT);
+#endif
 
 	agent_finalize_pending(agent, NULL);
 
 	agent_send_next_request(agent);
 }
 
+#ifdef HAVE_DBUS
 static void agent_receive_reply(struct l_dbus_message *message,
 							void *user_data)
 {
@@ -268,6 +289,7 @@ static void agent_receive_reply(struct l_dbus_message *message,
 	if (!agent->pending_id)
 		agent_send_next_request(agent);
 }
+#endif
 
 static void agent_send_next_request(struct agent *agent)
 {
@@ -283,16 +305,19 @@ static void agent_send_next_request(struct agent *agent)
 
 	l_debug("send request to %s %s", agent->owner, agent->path);
 
+#ifdef HAVE_DBUS
 	agent->pending_id = l_dbus_send_with_reply(dbus_get_bus(),
 							pending->message,
 							agent_receive_reply,
 							agent, NULL);
+#endif
 
 	pending->message = NULL;
 
 	return;
 }
 
+#ifdef HAVE_DBUS
 static unsigned int agent_queue_request(struct agent *agent,
 					enum agent_request_type type,
 					struct l_dbus_message *message,
@@ -472,6 +497,7 @@ unsigned int agent_request_user_password(const char *path, const char *user,
 					message, agent_timeout_input_request(),
 					callback, trigger, user_data, destroy);
 }
+#endif
 
 static bool find_request(const void *a, const void *b)
 {
@@ -500,9 +526,11 @@ bool agent_request_cancel(unsigned int req_id, int reason)
 		return false;
 
 	if (!request->message) {
+#ifdef HAVE_DBUS
 		send_cancel_request(agent, reason);
 
 		l_dbus_cancel(dbus_get_bus(), agent->pending_id);
+#endif
 
 		agent->pending_id = 0;
 
@@ -519,6 +547,7 @@ bool agent_request_cancel(unsigned int req_id, int reason)
 	return true;
 }
 
+#ifdef HAVE_DBUS
 static void agent_disconnect(struct l_dbus *dbus, void *user_data)
 {
 	struct agent *agent = user_data;
@@ -609,12 +638,15 @@ static void setup_agent_interface(struct l_dbus_interface *interface)
 				agent_unregister,
 				"", "o", "path");
 }
+#endif
 
 static bool release_agent(void *data, void *user_data)
 {
 	struct agent *agent = data;
 
+#ifdef HAVE_DBUS
 	send_request(agent, "Release");
+#endif
 
 	agent_free(agent);
 
@@ -623,10 +655,13 @@ static bool release_agent(void *data, void *user_data)
 
 static int agent_init(void)
 {
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
+#endif
 
 	agents = l_queue_new();
 
+#ifdef HAVE_DBUS
 	if (!l_dbus_register_interface(dbus, IWD_AGENT_MANAGER_INTERFACE,
 						setup_agent_interface,
 						NULL, false)) {
@@ -643,18 +678,21 @@ static int agent_init(void)
 		l_dbus_unregister_interface(dbus, IWD_AGENT_MANAGER_INTERFACE);
 		return -EIO;
 	}
+#endif
 
 	return 0;
 }
 
 static void agent_exit(void)
 {
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
 
 	l_dbus_unregister_object(dbus, IWD_AGENT_MANAGER_PATH);
 	l_dbus_unregister_interface(dbus, IWD_AGENT_MANAGER_INTERFACE);
 
 	l_queue_destroy(agents, agent_free);
+#endif
 	agents = NULL;
 }
 
diff --git a/src/ap.c b/src/ap.c
index 9c2ce27..e85d2f9 100644
--- a/src/ap.c
+++ b/src/ap.c
@@ -42,7 +42,9 @@
 #include "src/util.h"
 #include "src/eapol.h"
 #include "src/handshake.h"
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#endif
 #include "src/nl80211util.h"
 #include "src/frame-xchg.h"
 
@@ -87,6 +89,7 @@ struct sta_state {
 
 static uint32_t netdev_watch;
 
+#ifdef HAVE_DBUS
 static void ap_sta_free(void *data)
 {
 	struct sta_state *sta = data;
@@ -1564,7 +1567,6 @@ static int ap_stop(struct ap_state *ap, struct l_dbus_message *message)
 	}
 
 	ap->pending = l_dbus_message_ref(message);
-
 	return 0;
 }
 
@@ -1636,6 +1638,7 @@ static void ap_destroy_interface(void *user_data)
 
 	ap_free(ap);
 }
+#endif
 
 static void ap_add_interface(struct netdev *netdev)
 {
@@ -1650,15 +1653,19 @@ static void ap_add_interface(struct netdev *netdev)
 	ap->netdev = netdev;
 	ap->nl80211 = l_genl_family_new(iwd_get_genl(), NL80211_GENL_NAME);
 
+#ifdef HAVE_DBUS
 	/* setup ap dbus interface */
 	l_dbus_object_add_interface(dbus_get_bus(),
 			netdev_get_path(netdev), IWD_AP_INTERFACE, ap);
+#endif
 }
 
 static void ap_remove_interface(struct netdev *netdev)
 {
+#ifdef HAVE_DBUS
 	l_dbus_object_remove_interface(dbus_get_bus(),
 			netdev_get_path(netdev), IWD_AP_INTERFACE);
+#endif
 }
 
 static void ap_netdev_watch(struct netdev *netdev,
@@ -1684,8 +1691,10 @@ static int ap_init(void)
 {
 	netdev_watch = netdev_watch_add(ap_netdev_watch, NULL, NULL);
 
+#ifdef HAVE_DBUS
 	l_dbus_register_interface(dbus_get_bus(), IWD_AP_INTERFACE,
 			ap_setup_interface, ap_destroy_interface, false);
+#endif
 
 	return 0;
 }
@@ -1693,7 +1702,10 @@ static int ap_init(void)
 static void ap_exit(void)
 {
 	netdev_watch_remove(netdev_watch);
+
+#ifdef HAVE_DBUS
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_AP_INTERFACE);
+#endif
 }
 
 IWD_MODULE(ap, ap_init, ap_exit)
diff --git a/src/device.c b/src/device.c
index c24d7ed..9c878d6 100644
--- a/src/device.c
+++ b/src/device.c
@@ -36,7 +36,9 @@
 #include "src/wiphy.h"
 #include "src/scan.h"
 #include "src/netdev.h"
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#endif
 #include "src/frame-xchg.h"
 #include "src/station.h"
 
@@ -66,6 +68,7 @@ static void device_ap_roam_frame_event(const struct mmpdu_header *hdr,
 	station_ap_directed_roam(station, hdr, body, body_len);
 }
 
+#ifdef HAVE_DBUS
 static bool device_property_get_name(struct l_dbus *dbus,
 					struct l_dbus_message *message,
 					struct l_dbus_message_builder *builder,
@@ -281,6 +284,7 @@ static void setup_device_interface(struct l_dbus_interface *interface)
 					device_property_get_mode,
 					device_property_set_mode);
 }
+#endif
 
 static void device_wiphy_state_changed_event(struct wiphy *wiphy,
 					enum wiphy_state_watch_event event,
@@ -302,7 +306,9 @@ static void device_wiphy_state_changed_event(struct wiphy *wiphy,
 static struct device *device_create(struct wiphy *wiphy, struct netdev *netdev)
 {
 	struct device *device;
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
+#endif
 	uint32_t ifindex = netdev_get_ifindex(netdev);
 	const uint8_t action_ap_roam_prefix[2] = { 0x0a, 0x07 };
 
@@ -311,6 +317,7 @@ static struct device *device_create(struct wiphy *wiphy, struct netdev *netdev)
 	device->wiphy = wiphy;
 	device->netdev = netdev;
 
+#ifdef HAVE_DBUS
 	if (!l_dbus_object_add_interface(dbus, netdev_get_path(device->netdev),
 					IWD_DEVICE_INTERFACE, device))
 		l_info("Unable to register %s interface", IWD_DEVICE_INTERFACE);
@@ -319,6 +326,7 @@ static struct device *device_create(struct wiphy *wiphy, struct netdev *netdev)
 					L_DBUS_INTERFACE_PROPERTIES, device))
 		l_info("Unable to register %s interface",
 				L_DBUS_INTERFACE_PROPERTIES);
+#endif
 
 	/*
 	 * register for AP roam transition watch
@@ -337,6 +345,7 @@ static struct device *device_create(struct wiphy *wiphy, struct netdev *netdev)
 	return device;
 }
 
+#ifdef HAVE_DBUS
 static void device_free(struct device *device)
 {
 	l_debug("");
@@ -353,12 +362,14 @@ static void device_free(struct device *device)
 
 	l_free(device);
 }
+#endif
 
 static void device_netdev_notify(struct netdev *netdev,
 					enum netdev_watch_event event,
 					void *user_data)
 {
-	struct device *device;
+	struct device *device = NULL;
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
 	const char *path = netdev_get_path(netdev);
 
@@ -366,6 +377,7 @@ static void device_netdev_notify(struct netdev *netdev,
 
 	if (!device && event != NETDEV_WATCH_EVENT_NEW)
 		return;
+#endif
 
 	switch (event) {
 	case NETDEV_WATCH_EVENT_NEW:
@@ -380,47 +392,61 @@ static void device_netdev_notify(struct netdev *netdev,
 		device_create(netdev_get_wiphy(netdev), netdev);
 		break;
 	case NETDEV_WATCH_EVENT_DEL:
+#ifdef HAVE_DBUS
 		l_dbus_unregister_object(dbus, path);
+#endif
 		break;
 	case NETDEV_WATCH_EVENT_UP:
 		device->powered = true;
 
+#ifdef HAVE_DBUS
 		l_dbus_property_changed(dbus, path,
 					IWD_DEVICE_INTERFACE, "Powered");
+#endif
 		break;
 	case NETDEV_WATCH_EVENT_DOWN:
 		device->powered = false;
 
+#ifdef HAVE_DBUS
 		l_dbus_property_changed(dbus, path,
 					IWD_DEVICE_INTERFACE, "Powered");
+#endif
 		break;
 	case NETDEV_WATCH_EVENT_NAME_CHANGE:
+#ifdef HAVE_DBUS
 		l_dbus_property_changed(dbus, path,
 					IWD_DEVICE_INTERFACE, "Name");
+#endif
 		break;
 	case NETDEV_WATCH_EVENT_ADDRESS_CHANGE:
+#ifdef HAVE_DBUS
 		l_dbus_property_changed(dbus, path,
 					IWD_DEVICE_INTERFACE, "Address");
+#endif
 		break;
 	default:
 		break;
 	}
 }
 
+#ifdef HAVE_DBUS
 static void destroy_device_interface(void *user_data)
 {
 	struct device *device = user_data;
 
 	device_free(device);
 }
+#endif
 
 static int device_init(void)
 {
+#ifdef HAVE_DBUS
 	if (!l_dbus_register_interface(dbus_get_bus(),
 					IWD_DEVICE_INTERFACE,
 					setup_device_interface,
 					destroy_device_interface, false))
 		return false;
+#endif
 
 	netdev_watch = netdev_watch_add(device_netdev_notify, NULL, NULL);
 
@@ -431,7 +457,9 @@ static void device_exit(void)
 {
 	netdev_watch_remove(netdev_watch);
 
+#ifdef HAVE_DBUS
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_DEVICE_INTERFACE);
+#endif
 }
 
 IWD_MODULE(device, device_init, device_exit)
diff --git a/src/knownnetworks.c b/src/knownnetworks.c
index 53cfc30..3bd0eee 100644
--- a/src/knownnetworks.c
+++ b/src/knownnetworks.c
@@ -39,7 +39,11 @@
 #include "src/storage.h"
 #include "src/common.h"
 #include "src/network.h"
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#else
+#define IWD_BASE_PATH "/net/connman/iwd"
+#endif
 #include "src/knownnetworks.h"
 #include "src/scan.h"
 #include "src/util.h"
@@ -119,6 +123,7 @@ int known_network_offset(const struct network_info *target)
 	return -ENOENT;
 }
 
+#ifdef HAVE_DBUS
 static void known_network_register_dbus(struct network_info *network)
 {
 	const char *path = known_network_get_path(network);
@@ -133,6 +138,7 @@ static void known_network_register_dbus(struct network_info *network)
 		l_info("Unable to register %s interface",
 						L_DBUS_INTERFACE_PROPERTIES);
 }
+#endif
 
 static void known_network_set_autoconnect(struct network_info *network,
 							bool autoconnect)
@@ -142,8 +148,10 @@ static void known_network_set_autoconnect(struct network_info *network,
 
 	network->is_autoconnectable = autoconnect;
 
+#ifdef HAVE_DBUS
 	l_dbus_property_changed(dbus_get_bus(), known_network_get_path(network),
 				IWD_KNOWN_NETWORK_INTERFACE, "AutoConnect");
+#endif
 }
 
 static int known_network_touch(struct network_info *info)
@@ -343,10 +351,12 @@ void known_network_set_connected_time(struct network_info *network,
 
 	network->connected_time = connected_time;
 
+#ifdef HAVE_DBUS
 	l_dbus_property_changed(dbus_get_bus(),
 				known_network_get_path(network),
 				IWD_KNOWN_NETWORK_INTERFACE,
 				"LastConnectedTime");
+#endif
 
 	l_queue_remove(known_networks, network);
 	l_queue_insert(known_networks, network, connected_time_compare, NULL);
@@ -367,10 +377,12 @@ void known_network_update(struct network_info *network,
 		else if (!network->is_hidden && is_hidden)
 			num_known_hidden_networks++;
 
+#ifdef HAVE_DBUS
 		l_dbus_property_changed(dbus_get_bus(),
 					known_network_get_path(network),
 					IWD_KNOWN_NETWORK_INTERFACE,
 					"Hidden");
+#endif
 	}
 
 	network->is_hidden = is_hidden;
@@ -501,6 +513,7 @@ int known_network_add_frequency(struct network_info *info, uint32_t frequency)
 	return 0;
 }
 
+#ifdef HAVE_DBUS
 static struct l_dbus_message *known_network_forget(struct l_dbus *dbus,
 						struct l_dbus_message *message,
 						void *user_data)
@@ -640,6 +653,7 @@ static void setup_known_network_interface(struct l_dbus_interface *interface)
 				known_network_property_get_last_connected,
 				NULL);
 }
+#endif
 
 void known_networks_remove(struct network_info *network)
 {
@@ -647,8 +661,10 @@ void known_networks_remove(struct network_info *network)
 		num_known_hidden_networks--;
 
 	l_queue_remove(known_networks, network);
+#ifdef HAVE_DBUS
 	l_dbus_unregister_object(dbus_get_bus(),
 					known_network_get_path(network));
+#endif
 
 	WATCHLIST_NOTIFY(&known_network_watches,
 				known_networks_watch_func_t,
@@ -668,7 +684,9 @@ void known_networks_remove(struct network_info *network)
 void known_networks_add(struct network_info *network)
 {
 	l_queue_insert(known_networks, network, connected_time_compare, NULL);
+#ifdef HAVE_DBUS
 	known_network_register_dbus(network);
+#endif
 
 	WATCHLIST_NOTIFY(&known_network_watches,
 				known_networks_watch_func_t,
@@ -983,12 +1001,15 @@ void known_networks_watch_remove(uint32_t id)
 
 static int known_networks_init(void)
 {
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
+#endif
 	DIR *dir;
 	struct dirent *dirent;
 
 	L_AUTO_FREE_VAR(char *, storage_dir) = storage_get_path(NULL);
 
+#ifdef HAVE_DBUS
 	if (!l_dbus_register_interface(dbus, IWD_KNOWN_NETWORK_INTERFACE,
 						setup_known_network_interface,
 						NULL, false)) {
@@ -996,11 +1017,14 @@ static int known_networks_init(void)
 				IWD_KNOWN_NETWORK_INTERFACE);
 		return -EPERM;
 	}
+#endif
 
 	dir = opendir(storage_dir);
 	if (!dir) {
 		l_info("Unable to open %s: %s", storage_dir, strerror(errno));
+#ifdef HAVE_DBUS
 		l_dbus_unregister_interface(dbus, IWD_KNOWN_NETWORK_INTERFACE);
+#endif
 		return -ENOENT;
 	}
 
@@ -1047,14 +1071,18 @@ static int known_networks_init(void)
 
 static void known_networks_exit(void)
 {
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
+#endif
 
 	l_dir_watch_destroy(storage_dir_watch);
 
 	l_queue_destroy(known_networks, network_info_free);
 	known_networks = NULL;
 
+#ifdef HAVE_DBUS
 	l_dbus_unregister_interface(dbus, IWD_KNOWN_NETWORK_INTERFACE);
+#endif
 
 	watchlist_destroy(&known_network_watches);
 }
diff --git a/src/main.c b/src/main.c
index 8bcbb6a..ddafbac 100644
--- a/src/main.c
+++ b/src/main.c
@@ -36,7 +36,9 @@
 #include "src/iwd.h"
 #include "src/module.h"
 #include "src/wiphy.h"
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#endif
 #include "src/eap.h"
 #include "src/eapol.h"
 #include "src/rfkill.h"
@@ -77,7 +79,9 @@ static void iwd_shutdown(void)
 		return;
 	}
 
+#ifdef HAVE_DBUS
 	dbus_shutdown();
+#endif
 	netdev_shutdown();
 
 	timeout = l_timeout_create(1, main_loop_quit, NULL, NULL);
@@ -135,7 +139,9 @@ static void usage(void)
 		"Usage:\n");
 	printf("\tiwd [options]\n");
 	printf("Options:\n"
+#ifdef HAVE_DBUS
 		"\t-B, --dbus-debug       Enable D-Bus debugging\n"
+#endif
 		"\t-i, --interfaces       Interfaces to manage\n"
 		"\t-I, --nointerfaces     Interfaces to ignore\n"
 		"\t-p, --phys             Phys to manage\n"
@@ -148,7 +154,9 @@ static void usage(void)
 }
 
 static const struct option main_options[] = {
+#ifdef HAVE_DBUS
 	{ "dbus-debug",   no_argument,       NULL, 'B' },
+#endif
 	{ "version",      no_argument,       NULL, 'v' },
 	{ "interfaces",   required_argument, NULL, 'i' },
 	{ "nointerfaces", required_argument, NULL, 'I' },
@@ -183,6 +191,7 @@ static void nl80211_appeared(const struct l_genl_family_info *info,
 	plugin_init(plugins, noplugins);
 }
 
+#ifdef HAVE_DBUS
 static void request_name_callback(struct l_dbus *dbus, bool success,
 					bool queued, void *user_data)
 {
@@ -216,6 +225,7 @@ static void dbus_disconnected(void *user_data)
 	l_info("D-Bus disconnected, quitting...");
 	iwd_shutdown();
 }
+#endif
 
 static void print_koption(const void *key, void *value, void *user_data)
 {
@@ -369,9 +379,13 @@ done:
 
 int main(int argc, char *argv[])
 {
+#ifdef HAVE_DBUS
 	bool enable_dbus_debug = false;
+#endif
 	int exit_status;
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus;
+#endif
 	const char *config_dir;
 	char **config_dirs;
 	int i;
@@ -385,9 +399,11 @@ int main(int argc, char *argv[])
 			break;
 
 		switch (opt) {
+#ifdef HAVE_DBUS
 		case 'B':
 			enable_dbus_debug = true;
 			break;
+#endif
 		case 'i':
 			interfaces = optarg;
 			break;
@@ -496,6 +512,7 @@ int main(int argc, char *argv[])
 	if (getenv("IWD_RTNL_DEBUG"))
 		l_netlink_set_debug(rtnl, do_debug, "[RTNL] ", NULL);
 
+#ifdef HAVE_DBUS
 	dbus = l_dbus_new_default(L_DBUS_SYSTEM_BUS);
 	if (!dbus) {
 		l_error("Failed to initialize D-Bus");
@@ -508,13 +525,20 @@ int main(int argc, char *argv[])
 	l_dbus_set_ready_handler(dbus, dbus_ready, dbus, NULL);
 	l_dbus_set_disconnect_handler(dbus, dbus_disconnected, NULL, NULL);
 	dbus_init(dbus);
+#else
+	l_genl_request_family(genl, NL80211_GENL_NAME, nl80211_appeared,
+				NULL, NULL);
+#endif
 
 	exit_status = l_main_run_with_signal(signal_handler, NULL);
 
 	plugin_exit();
 	iwd_modules_exit();
+
+#ifdef HAVE_DBUS
 	dbus_exit();
 	l_dbus_destroy(dbus);
+#endif
 
 failed_dbus:
 	l_netlink_destroy(rtnl);
diff --git a/src/network.c b/src/network.c
index c08d7e7..e38508c 100644
--- a/src/network.c
+++ b/src/network.c
@@ -40,7 +40,9 @@
 #include "src/common.h"
 #include "src/storage.h"
 #include "src/scan.h"
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#endif
 #include "src/agent.h"
 #include "src/netdev.h"
 #include "src/wiphy.h"
@@ -489,8 +491,10 @@ void network_set_info(struct network *network, struct network_info *info)
 		network->info = NULL;
 	}
 
+#ifdef HAVE_DBUS
 	l_dbus_property_changed(dbus_get_bus(), network_get_path(network),
 					IWD_NETWORK_INTERFACE, "KnownNetwork");
+#endif
 }
 
 static inline bool __bss_is_sae(const struct scan_bss *bss,
@@ -502,6 +506,7 @@ static inline bool __bss_is_sae(const struct scan_bss *bss,
 	return false;
 }
 
+#ifdef HAVE_DBUS
 static bool bss_is_sae(const struct scan_bss *bss)
 {
 	struct ie_rsn_info rsn;
@@ -511,6 +516,7 @@ static bool bss_is_sae(const struct scan_bss *bss)
 
 	return __bss_is_sae(bss, &rsn);
 }
+#endif
 
 int network_autoconnect(struct network *network, struct scan_bss *bss)
 {
@@ -744,6 +750,7 @@ struct scan_bss *network_bss_select(struct network *network,
 	return NULL;
 }
 
+#ifdef HAVE_DBUS
 static void passphrase_callback(enum agent_result result,
 				const char *passphrase,
 				struct l_dbus_message *message,
@@ -859,6 +866,7 @@ static struct l_dbus_message *network_connect_psk(struct network *network,
 
 	return NULL;
 }
+#endif
 
 struct eap_secret_request {
 	struct network *network;
@@ -869,6 +877,7 @@ struct eap_secret_request {
 				struct eap_secret_request *req);
 };
 
+#ifdef HAVE_DBUS
 static void eap_secret_request_free(void *data)
 {
 	struct eap_secret_request *req = data;
@@ -1210,6 +1219,7 @@ void network_connect_new_hidden_network(struct network *network,
 reply_error:
 	dbus_pending_reply(&message, error);
 }
+#endif
 
 void network_blacklist_add(struct network *network, struct scan_bss *bss)
 {
@@ -1224,6 +1234,7 @@ const struct iovec *network_get_extra_ies(struct network *network,
 	return network_info_get_extra_ies(network->info, bss, num_elems);
 }
 
+#ifdef HAVE_DBUS
 static bool network_property_get_name(struct l_dbus *dbus,
 					struct l_dbus_message *message,
 					struct l_dbus_message_builder *builder,
@@ -1295,9 +1306,11 @@ static bool network_property_get_known_network(struct l_dbus *dbus,
 
 	return true;
 }
+#endif
 
 bool network_register(struct network *network, const char *path)
 {
+#ifdef HAVE_DBUS
 	if (!l_dbus_object_add_interface(dbus_get_bus(), path,
 					IWD_NETWORK_INTERFACE, network)) {
 		l_info("Unable to register %s interface",
@@ -1309,6 +1322,7 @@ bool network_register(struct network *network, const char *path)
 					L_DBUS_INTERFACE_PROPERTIES, network))
 		l_info("Unable to register %s interface",
 						L_DBUS_INTERFACE_PROPERTIES);
+#endif
 
 	network->object_path = l_strdup(path);
 
@@ -1317,12 +1331,16 @@ bool network_register(struct network *network, const char *path)
 
 static void network_unregister(struct network *network, int reason)
 {
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
+#endif
 
 	agent_request_cancel(network->agent_request, reason);
 	network_settings_close(network);
 
+#ifdef HAVE_DBUS
 	l_dbus_unregister_object(dbus, network->object_path);
+#endif
 
 	l_free(network->object_path);
 	network->object_path = NULL;
@@ -1484,6 +1502,7 @@ static void known_networks_changed(enum known_networks_event event,
 	}
 }
 
+#ifdef HAVE_DBUS
 static void setup_network_interface(struct l_dbus_interface *interface)
 {
 	l_dbus_interface_method(interface, "Connect", 0,
@@ -1506,13 +1525,16 @@ static void setup_network_interface(struct l_dbus_interface *interface)
 	l_dbus_interface_property(interface, "KnownNetwork", 0, "o",
 				network_property_get_known_network, NULL);
 }
+#endif
 
 static int network_init(void)
 {
+#ifdef HAVE_DBUS
 	if (!l_dbus_register_interface(dbus_get_bus(), IWD_NETWORK_INTERFACE,
 					setup_network_interface, NULL, false))
 		l_error("Unable to register %s interface",
 						IWD_NETWORK_INTERFACE);
+#endif
 
 	known_networks_watch =
 		known_networks_watch_add(known_networks_changed, NULL, NULL);
@@ -1525,7 +1547,9 @@ static void network_exit(void)
 	known_networks_watch_remove(known_networks_watch);
 	known_networks_watch = 0;
 
+#ifdef HAVE_DBUS
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_NETWORK_INTERFACE);
+#endif
 }
 
 IWD_MODULE(network, network_init, network_exit)
diff --git a/src/resolve.c b/src/resolve.c
index af0c1a0..ae159fc 100644
--- a/src/resolve.c
+++ b/src/resolve.c
@@ -34,7 +34,9 @@
 
 #include "src/iwd.h"
 #include "src/module.h"
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#endif
 #include "src/resolve.h"
 
 struct resolve_method_ops {
@@ -64,6 +66,7 @@ struct systemd_state {
 	bool is_ready:1;
 };
 
+#ifdef HAVE_DBUS
 static void systemd_link_dns_reply(struct l_dbus_message *message,
 								void *user_data)
 {
@@ -302,6 +305,7 @@ static const struct resolve_method_ops resolve_method_systemd = {
 	.add_domain_name = resolve_systemd_add_domain_name,
 	.remove = resolve_systemd_remove,
 };
+#endif
 
 static void resolve_resolvconf_add_dns(uint32_t ifindex, uint8_t type,
 						char **dns_list, void *data)
@@ -450,7 +454,9 @@ static const struct {
 	const char *name;
 	const struct resolve_method_ops *method_ops;
 } resolve_method_ops_list[] = {
+#ifdef HAVE_DBUS
 	{ "systemd", &resolve_method_systemd },
+#endif
 	{ "resolvconf", &resolve_method_resolvconf },
 	{ }
 };
@@ -481,7 +487,11 @@ static int resolve_init(void)
 			l_warn("[General].dns_resolve_method is deprecated, "
 				"use [Network].NameResolvingService");
 		else /* Default to systemd-resolved service. */
+#ifdef HAVE_DBUS
 			method_name = "systemd";
+#else
+			method_name = "resolvconf";
+#endif
 	}
 
 	for (i = 0; resolve_method_ops_list[i].name; i++) {
diff --git a/src/station.c b/src/station.c
index d57a0f8..50ea5c9 100644
--- a/src/station.c
+++ b/src/station.c
@@ -40,7 +40,9 @@
 #include "src/watchlist.h"
 #include "src/scan.h"
 #include "src/netdev.h"
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#endif
 #include "src/wiphy.h"
 #include "src/network.h"
 #include "src/knownnetworks.h"
@@ -151,9 +153,11 @@ static void station_property_set_scanning(struct station *station,
 
 	station->scanning = scanning;
 
+#ifdef HAVE_DBUS
 	l_dbus_property_changed(dbus_get_bus(),
 				netdev_get_path(station->netdev),
 					IWD_STATION_INTERFACE, "Scanning");
+#endif
 }
 
 static void station_enter_state(struct station *station,
@@ -221,12 +225,16 @@ static void bss_free(void *data)
 	scan_bss_free(bss);
 }
 
+#ifdef HAVE_CONFIG_H
+#ifdef HAVE_DBUS
 static void network_free(void *data)
 {
 	struct network *network = data;
 
 	network_remove(network, -ESHUTDOWN);
 }
+#endif
+#endif
 
 static bool process_network(const void *key, void *data, void *user_data)
 {
@@ -1154,19 +1162,23 @@ static void station_enter_state(struct station *station,
 						enum station_state state)
 {
 	uint64_t id = netdev_get_wdev_id(station->netdev);
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
 	bool disconnected;
+#endif
 
 	l_debug("Old State: %s, new state: %s",
 			station_state_to_string(station->state),
 			station_state_to_string(state));
 
+#ifdef HAVE_DBUS
 	disconnected = !station_is_busy(station);
 
 	if ((disconnected && state > STATION_STATE_AUTOCONNECT_FULL) ||
 			(!disconnected && state != station->state))
 		l_dbus_property_changed(dbus, netdev_get_path(station->netdev),
 					IWD_STATION_INTERFACE, "State");
+#endif
 
 	switch (state) {
 	case STATION_STATE_AUTOCONNECT_QUICK:
@@ -1177,11 +1189,13 @@ static void station_enter_state(struct station *station,
 					new_scan_results, station);
 		break;
 	case STATION_STATE_CONNECTING:
+#ifdef HAVE_DBUS
 		l_dbus_property_changed(dbus, netdev_get_path(station->netdev),
 				IWD_STATION_INTERFACE, "ConnectedNetwork");
 		l_dbus_property_changed(dbus,
 				network_get_path(station->connected_network),
 				IWD_NETWORK_INTERFACE, "Connected");
+#endif
 		/* fall through */
 	case STATION_STATE_DISCONNECTED:
 	case STATION_STATE_CONNECTED:
@@ -1249,7 +1263,9 @@ static void station_roam_state_clear(struct station *station)
 static void station_reset_connection_state(struct station *station)
 {
 	struct network *network = station->connected_network;
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
+#endif
 
 	if (!network)
 		return;
@@ -1264,10 +1280,12 @@ static void station_reset_connection_state(struct station *station)
 	station->connected_bss = NULL;
 	station->connected_network = NULL;
 
+#ifdef HAVE_DBUS
 	l_dbus_property_changed(dbus, netdev_get_path(station->netdev),
 				IWD_STATION_INTERFACE, "ConnectedNetwork");
 	l_dbus_property_changed(dbus, network_get_path(network),
 				IWD_NETWORK_INTERFACE, "Connected");
+#endif
 }
 
 static void station_disassociated(struct station *station)
@@ -2245,6 +2263,7 @@ static bool station_retry_with_status(struct station *station,
 	return station_try_next_bss(station);
 }
 
+#ifdef HAVE_DBUS
 static void station_connect_dbus_reply(struct station *station,
 					enum netdev_result result)
 {
@@ -2265,6 +2284,7 @@ static void station_connect_dbus_reply(struct station *station,
 
 	dbus_pending_reply(&station->connect_pending, reply);
 }
+#endif
 
 static void station_connect_cb(struct netdev *netdev, enum netdev_result result,
 					void *event_data, void *user_data)
@@ -2294,8 +2314,10 @@ static void station_connect_cb(struct netdev *netdev, enum netdev_result result,
 		break;
 	}
 
+#ifdef HAVE_DBUS
 	if (station->connect_pending)
 		station_connect_dbus_reply(station, result);
+#endif
 
 	if (result != NETDEV_RESULT_OK) {
 		if (result != NETDEV_RESULT_ABORTED) {
@@ -2347,6 +2369,7 @@ int __station_connect_network(struct station *station, struct network *network,
 	return 0;
 }
 
+#ifdef HAVE_DBUS
 static void station_disconnect_onconnect_cb(struct netdev *netdev, bool success,
 					void *user_data)
 {
@@ -2371,18 +2394,21 @@ static void station_disconnect_onconnect_cb(struct netdev *netdev, bool success,
 
 	station_enter_state(station, STATION_STATE_CONNECTING);
 }
+#endif
 
 static void station_disconnect_onconnect(struct station *station,
 					struct network *network,
 					struct scan_bss *bss,
 					struct l_dbus_message *message)
 {
+#ifdef HAVE_DBUS
 	if (netdev_disconnect(station->netdev, station_disconnect_onconnect_cb,
 								station) < 0) {
 		l_dbus_send(dbus_get_bus(),
 					dbus_error_from_errno(-EIO, message));
 		return;
 	}
+#endif
 
 	if (station->netconfig)
 		netconfig_reset(station->netconfig);
@@ -2394,14 +2420,18 @@ static void station_disconnect_onconnect(struct station *station,
 	station->connect_pending_network = network;
 	station->connect_pending_bss = bss;
 
+#ifdef HAVE_DBUS
 	station->connect_pending = l_dbus_message_ref(message);
+#endif
 }
 
 void station_connect_network(struct station *station, struct network *network,
 				struct scan_bss *bss,
 				struct l_dbus_message *message)
 {
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
+#endif
 	int err;
 
 	if (station_is_busy(station)) {
@@ -2416,15 +2446,22 @@ void station_connect_network(struct station *station, struct network *network,
 
 	station_enter_state(station, STATION_STATE_CONNECTING);
 
+#ifdef HAVE_DBUS
 	station->connect_pending = l_dbus_message_ref(message);
+#endif
 	station->autoconnect = true;
 
 	return;
 
 error:
+#ifdef HAVE_DBUS
 	l_dbus_send(dbus, dbus_error_from_errno(err, message));
+#else
+    return;
+#endif
 }
 
+#ifdef HAVE_DBUS
 static void station_hidden_network_scan_triggered(int err, void *user_data)
 {
 	struct station *station = user_data;
@@ -2558,6 +2595,7 @@ static struct l_dbus_message *station_dbus_connect_hidden_network(
 
 	return NULL;
 }
+#endif
 
 static void station_disconnect_reconnect_cb(struct netdev *netdev, bool success,
 					void *user_data)
@@ -2589,6 +2627,7 @@ static void station_disconnect_cb(struct netdev *netdev, bool success,
 	l_debug("%u, success: %d",
 			netdev_get_ifindex(station->netdev), success);
 
+#ifdef HAVE_DBUS
 	if (station->disconnect_pending) {
 		struct l_dbus_message *reply;
 
@@ -2602,6 +2641,7 @@ static void station_disconnect_cb(struct netdev *netdev, bool success,
 		dbus_pending_reply(&station->disconnect_pending, reply);
 
 	}
+#endif
 
 	station_enter_state(station, STATION_STATE_DISCONNECTED);
 
@@ -2636,6 +2676,7 @@ int station_disconnect(struct station *station)
 	return 0;
 }
 
+#ifdef HAVE_DBUS
 static struct l_dbus_message *station_dbus_disconnect(struct l_dbus *dbus,
 						struct l_dbus_message *message,
 						void *user_data)
@@ -2803,6 +2844,7 @@ static struct l_dbus_message *station_dbus_scan(struct l_dbus *dbus,
 
 	return NULL;
 }
+#endif
 
 struct signal_agent {
 	char *owner;
@@ -2813,6 +2855,7 @@ struct signal_agent {
 static void station_signal_agent_notify(struct signal_agent *agent,
 					const char *device_path, uint8_t level)
 {
+#ifdef HAVE_DBUS
 	struct l_dbus_message *msg;
 
 	msg = l_dbus_message_new_method_call(dbus_get_bus(),
@@ -2823,6 +2866,7 @@ static void station_signal_agent_notify(struct signal_agent *agent,
 	l_dbus_message_set_no_reply(msg, true);
 
 	l_dbus_send(dbus_get_bus(), msg);
+#endif
 }
 
 static void station_rssi_level_changed(struct station *station,
@@ -2837,6 +2881,7 @@ static void station_rssi_level_changed(struct station *station,
 					netdev_get_path(netdev), level_idx);
 }
 
+#ifdef HAVE_DBUS
 static void station_signal_agent_release(struct signal_agent *agent,
 						const char *device_path)
 {
@@ -3009,6 +3054,7 @@ static bool station_property_get_state(struct l_dbus *dbus,
 	l_dbus_message_builder_append_basic(builder, 's', statestr);
 	return true;
 }
+#endif
 
 void station_foreach(station_foreach_func_t func, void *user_data)
 {
@@ -3075,7 +3121,9 @@ struct scan_bss *station_get_connected_bss(struct station *station)
 static struct station *station_create(struct netdev *netdev)
 {
 	struct station *station;
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
+#endif
 
 	station = l_new(struct station, 1);
 	watchlist_init(&station->state_watches, NULL);
@@ -3095,8 +3143,10 @@ static struct station *station_create(struct netdev *netdev)
 
 	station_set_autoconnect(station, true);
 
+#ifdef HAVE_DBUS
 	l_dbus_object_add_interface(dbus, netdev_get_path(netdev),
 					IWD_STATION_INTERFACE, station);
+#endif
 
 	station->netconfig = netconfig_new(netdev_get_ifindex(netdev));
 
@@ -3105,6 +3155,7 @@ static struct station *station_create(struct netdev *netdev)
 	return station;
 }
 
+#ifdef HAVE_DBUS
 static void station_free(struct station *station)
 {
 	l_debug("");
@@ -3205,6 +3256,7 @@ static void station_destroy_interface(void *user_data)
 
 	station_free(station);
 }
+#endif
 
 static void station_netdev_watch(struct netdev *netdev,
 				enum netdev_watch_event event, void *userdata)
@@ -3218,9 +3270,11 @@ static void station_netdev_watch(struct netdev *netdev,
 		break;
 	case NETDEV_WATCH_EVENT_DOWN:
 	case NETDEV_WATCH_EVENT_DEL:
+#ifdef HAVE_DBUS
 		l_dbus_object_remove_interface(dbus_get_bus(),
 						netdev_get_path(netdev),
 						IWD_STATION_INTERFACE);
+#endif
 		break;
 	default:
 		break;
@@ -3231,9 +3285,11 @@ static int station_init(void)
 {
 	station_list = l_queue_new();
 	netdev_watch = netdev_watch_add(station_netdev_watch, NULL, NULL);
+#ifdef HAVE_DBUS
 	l_dbus_register_interface(dbus_get_bus(), IWD_STATION_INTERFACE,
 					station_setup_interface,
 					station_destroy_interface, false);
+#endif
 
 	if (!l_settings_get_uint(iwd_get_config(), "General",
 					"ManagementFrameProtection",
@@ -3255,7 +3311,9 @@ static int station_init(void)
 
 static void station_exit(void)
 {
+#ifdef HAVE_DBUS
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_STATION_INTERFACE);
+#endif
 	netdev_watch_remove(netdev_watch);
 	l_queue_destroy(station_list, NULL);
 	station_list = NULL;
diff --git a/src/wiphy.c b/src/wiphy.c
index 8abf1b0..33ab3e6 100644
--- a/src/wiphy.c
+++ b/src/wiphy.c
@@ -44,7 +44,33 @@
 #include "src/crypto.h"
 #include "src/scan.h"
 #include "src/netdev.h"
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#else
+#define IWD_BASE_PATH "/net/connman/iwd"
+
+const char *dbus_iftype_to_string(uint32_t iftype)
+{
+	switch (iftype) {
+	case NL80211_IFTYPE_ADHOC:
+		return "ad-hoc";
+	case NL80211_IFTYPE_STATION:
+		return "station";
+	case NL80211_IFTYPE_AP:
+		return "ap";
+	case NL80211_IFTYPE_P2P_CLIENT:
+		return "p2p-client";
+	case NL80211_IFTYPE_P2P_GO:
+		return "p2p-go";
+	case NL80211_IFTYPE_P2P_DEVICE:
+		return "p2p-device";
+	default:
+		break;
+	}
+
+	return NULL;
+}
+#endif
 #include "src/rfkill.h"
 #include "src/wiphy.h"
 #include "src/storage.h"
@@ -989,7 +1015,9 @@ static int wiphy_get_permanent_addr_from_sysfs(struct wiphy *wiphy)
 
 static void wiphy_register(struct wiphy *wiphy)
 {
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
+#endif
 
 	wiphy->soft_rfkill = rfkill_get_soft_state(wiphy->id);
 	wiphy->hard_rfkill = rfkill_get_hard_state(wiphy->id);
@@ -1029,6 +1057,7 @@ static void wiphy_register(struct wiphy *wiphy)
 
 	wiphy_get_driver_name(wiphy);
 
+#ifdef HAVE_DBUS
 	if (!l_dbus_object_add_interface(dbus, wiphy_get_path(wiphy),
 					IWD_WIPHY_INTERFACE, wiphy))
 		l_info("Unable to add the %s interface to %s",
@@ -1039,6 +1068,7 @@ static void wiphy_register(struct wiphy *wiphy)
 		l_info("Unable to add the %s interface to %s",
 				L_DBUS_INTERFACE_PROPERTIES,
 				wiphy_get_path(wiphy));
+#endif
 
 	wiphy->registered = true;
 }
@@ -1069,6 +1099,7 @@ void wiphy_update_from_genl(struct wiphy *wiphy, struct l_genl_msg *msg)
 
 void wiphy_update_name(struct wiphy *wiphy, const char *name)
 {
+#ifdef HAVE_DBUS
 	bool updated = false;
 
 	if (strncmp(wiphy->name, name, sizeof(wiphy->name))) {
@@ -1082,6 +1113,7 @@ void wiphy_update_name(struct wiphy *wiphy, const char *name)
 		l_dbus_property_changed(dbus, wiphy_get_path(wiphy),
 					IWD_WIPHY_INTERFACE, "Name");
 	}
+#endif
 }
 
 static void wiphy_set_station_capability_bits(struct wiphy *wiphy)
@@ -1163,8 +1195,10 @@ bool wiphy_destroy(struct wiphy *wiphy)
 	if (!l_queue_remove(wiphy_list, wiphy))
 		return false;
 
+#ifdef HAVE_DBUS
 	if (wiphy->registered)
 		l_dbus_unregister_object(dbus_get_bus(), wiphy_get_path(wiphy));
+#endif
 
 	wiphy_free(wiphy);
 	return true;
@@ -1174,7 +1208,9 @@ static void wiphy_rfkill_cb(unsigned int wiphy_id, bool soft, bool hard,
 				void *user_data)
 {
 	struct wiphy *wiphy = wiphy_find(wiphy_id);
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
+#endif
 	bool old_powered, new_powered;
 	enum wiphy_state_watch_event event;
 
@@ -1196,10 +1232,13 @@ static void wiphy_rfkill_cb(unsigned int wiphy_id, bool soft, bool hard,
 	WATCHLIST_NOTIFY(&wiphy->state_watches, wiphy_state_watch_func_t,
 				wiphy, event);
 
+#ifdef HAVE_DBUS
 	l_dbus_property_changed(dbus, wiphy_get_path(wiphy),
 					IWD_WIPHY_INTERFACE, "Powered");
+#endif
 }
 
+#ifdef HAVE_DBUS
 static bool wiphy_property_get_powered(struct l_dbus *dbus,
 					struct l_dbus_message *message,
 					struct l_dbus_message_builder *builder,
@@ -1337,6 +1376,7 @@ static void setup_wiphy_interface(struct l_dbus_interface *interface)
 					wiphy_property_get_supported_modes,
 					NULL);
 }
+#endif
 
 static int wiphy_init(void)
 {
@@ -1361,12 +1401,14 @@ static int wiphy_init(void)
 
 	rfkill_watch_add(wiphy_rfkill_cb, NULL);
 
+#ifdef HAVE_DBUS
 	if (!l_dbus_register_interface(dbus_get_bus(),
 					IWD_WIPHY_INTERFACE,
 					setup_wiphy_interface,
 					NULL, false))
 		l_error("Unable to register the %s interface",
 				IWD_WIPHY_INTERFACE);
+#endif
 
 	hwdb = l_hwdb_new_default();
 
@@ -1403,7 +1445,9 @@ static void wiphy_exit(void)
 	nl80211 = NULL;
 	mac_randomize_bytes = 6;
 
+#ifdef HAVE_DBUS
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_WIPHY_INTERFACE);
+#endif
 
 	l_hwdb_unref(hwdb);
 }
diff --git a/src/wsc.c b/src/wsc.c
index 2ac6de9..6572bf7 100644
--- a/src/wsc.c
+++ b/src/wsc.c
@@ -30,7 +30,9 @@
 
 #include "src/missing.h"
 #include "src/module.h"
+#ifdef HAVE_DBUS
 #include "src/dbus.h"
+#endif
 #include "src/netdev.h"
 #include "src/wiphy.h"
 #include "src/station.h"
@@ -61,6 +63,7 @@ struct wsc_enrollee {
 	bool disconnecting : 1;
 };
 
+#ifdef HAVE_DBUS
 static struct l_dbus_message *wsc_error_session_overlap(
 						struct l_dbus_message *msg)
 {
@@ -100,6 +103,7 @@ static struct l_dbus_message *wsc_error_time_expired(struct l_dbus_message *msg)
 					"No APs in PIN mode found in "
 					"the allotted time");
 }
+#endif
 
 static void wsc_enrollee_connect_cb(struct netdev *netdev,
 					enum netdev_result result,
@@ -461,6 +465,7 @@ struct wsc_station_dbus {
 	uint32_t station_state_watch;
 };
 
+#ifdef HAVE_DBUS
 #define CONNECT_REPLY(wsc, message)					\
 	if ((wsc)->super.pending_connect)				\
 		dbus_pending_reply(&(wsc)->super.pending_connect,	\
@@ -471,6 +476,12 @@ struct wsc_station_dbus {
 		dbus_pending_reply(&(wsc)->super.pending_cancel,	\
 				message((wsc)->super.pending_cancel))	\
 
+#else
+#define CONNECT_REPLY(wsc, message) do {} while(0)
+#define CANCEL_REPLY(wsc, message)  do {} while(0)
+#endif
+
+#ifdef HAVE_DBUS
 static void wsc_try_credentials(struct wsc_station_dbus *wsc,
 				struct wsc_credentials_info *creds,
 				unsigned int n_creds)
@@ -1234,10 +1245,13 @@ static void wsc_dbus_free(void *user_data)
 
 	wsc->remove(wsc);
 }
+#endif
 
 static void wsc_add_station(struct netdev *netdev)
 {
+#ifdef HAVE_DBUS
 	struct wsc_station_dbus *wsc;
+#endif
 
 	if (!wiphy_get_max_scan_ie_len(netdev_get_wiphy(netdev))) {
 		l_debug("Simple Configuration isn't supported by ifindex %u",
@@ -1246,6 +1260,7 @@ static void wsc_add_station(struct netdev *netdev)
 		return;
 	}
 
+#ifdef HAVE_DBUS
 	wsc = l_new(struct wsc_station_dbus, 1);
 	wsc->netdev = netdev;
 	wsc->super.get_path = wsc_station_dbus_get_path;
@@ -1255,14 +1270,17 @@ static void wsc_add_station(struct netdev *netdev)
 
 	if (!wsc_dbus_add_interface(&wsc->super))
 		wsc_station_dbus_remove(&wsc->super);
+#endif
 }
 
 static void wsc_remove_station(struct netdev *netdev)
 {
+#ifdef HAVE_DBUS
 	struct l_dbus *dbus = dbus_get_bus();
 
 	l_dbus_object_remove_interface(dbus, netdev_get_path(netdev),
 					IWD_WSC_INTERFACE);
+#endif
 }
 
 static void wsc_netdev_watch(struct netdev *netdev,
@@ -1288,16 +1306,20 @@ static int wsc_init(void)
 {
 	l_debug("");
 	netdev_watch = netdev_watch_add(wsc_netdev_watch, NULL, NULL);
+#ifdef HAVE_DBUS
 	l_dbus_register_interface(dbus_get_bus(), IWD_WSC_INTERFACE,
 					setup_wsc_interface,
 					wsc_dbus_free, false);
+#endif
 	return 0;
 }
 
 static void wsc_exit(void)
 {
 	l_debug("");
+#ifdef HAVE_DBUS
 	l_dbus_unregister_interface(dbus_get_bus(), IWD_WSC_INTERFACE);
+#endif
 	netdev_watch_remove(netdev_watch);
 }
 
