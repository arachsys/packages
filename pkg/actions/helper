if [[ ! -f /pkg/build ]]; then
  die "${0##*/} helper is for internal use only"
fi

PKG=/pkg
setup "${@:3}"
source /pkg/build

if [[ $1 == requirements ]]; then
  if [[ ${#REQUIREMENTS[@]} -gt 0 ]]; then
    printf '%s\n' "${!REQUIREMENTS[@]}"
  fi
elif [[ $1 == check ]]; then
  match() {
    PATTERN=$3 REPLACE=${4:-\\1} gawk -e '{
      while (ENVIRON["PATTERN"] && match($0, ENVIRON["PATTERN"])) {
        print gensub(ENVIRON["PATTERN"], ENVIRON["REPLACE"], 1,
          substr($0, RSTART, RLENGTH));
        $0 = substr($0, RSTART + RLENGTH);
      }
    }' | sort -V | tail -n 1 | if ! read VERSION; then
      warn "$PKGNAME: $1 not found"
    elif [[ $2 != $VERSION ]]; then
      echo "$PKGNAME: $1 $VERSION available"
    fi
  }

  url() {
    exec < <(curl -f -m 30 -s -L -- "$1" || die "$PKGNAME: failed to get $1")
  }

  cd /pkg && PKGNAME=$2 check "${@:2}" </dev/null
elif [[ $1 == prepare ]] && [[ -d /src ]]; then
  if ( set -- /src/* && [[ $# -ne 0 ]] ); then
    die "Cannot unpack sources: directory is not empty"
  fi
  cd /src && prepare "${@:2}"
  find /src -depth -exec touch -r /src {} +
elif [[ $1 == build ]] && [[ -d /src ]] && [[ -d /dst ]]; then
  image() (
    if [[ $2 == contains ]] && [[ $1 != ?(-) ]]; then
      cd /dst && mkdir -p "/img/$1"
      while [[ $# -gt 2 ]]; do
        cp -a -l -t "/img/$1" --parents -- "${3#/dst/}"
        rm -f -r -- "${3#/dst/}"
        set -- "$1" "$2" "${@:4}"
      done
    elif [[ $2 == requires ]] && [[ $# -gt 2 ]]; then
      if [[ $1 == ?(-) ]]; then
        mkdir -p /dst/info
        printf '%s\n' "${@:3}" >>/dst/info/requirements
      else
        mkdir -p "/img/$1/info"
        printf '%s\n' "${@:3}" >>/img/$1/info/requirements
      fi
    else
      die "Invalid command: image $*"
    fi
  )

  if ( set -- /src/* && [[ $# -eq 0 ]] ); then
    cd /src && prepare "${@:2}"
    find /src -depth -exec touch -r /src {} +
  fi
  cd /src && build "${@:2}" 2>&1

  tidy /img/*
  for IMG in /img/*; do
    if [[ -d "$IMG" ]]; then
      mkdir -p "$IMG/info"
      printf '%s\n' "$2" >"$IMG/info/source"
    fi
    if [[ -f "$IMG/info/requirements" ]]; then
      sort -o "$IMG/info/requirements" -u "$IMG/info/requirements"
    fi
  done
  find /img -depth -exec touch -d $(date +@%s) {} +
else
  die "$0 helper action is for internal use only"
fi
