declare -A FEATURES=()
declare -A REQUIREMENTS=()

apply() {
  local DIR OPTARG OPTIND OPTION STRIP=1
  while getopts :d:p: OPTION; do
    case $OPTION in
      d)
        if ! mkdir -p -- "$OPTARG" 2>/dev/null; then
          die "Failed to create directory $OPTARG"
        fi
        DIR=$OPTARG
        ;;
      p)
        if [[ $OPTARG != @(0|[1-9]*([0-9])) ]]; then
          die "Invalid prefix length to strip"
        fi
        STRIP=$OPTARG
        ;;
    esac
  done
  shift $((OPTIND - 1))

  if [[ $# -eq 1 ]] && [[ -f $PKG/$1 ]]; then
    set -- "$PKG/$1"
  fi

  if ! fetch "$@" | bsdcat | patch -d "${DIR:-.}" -p $STRIP -s -t -N \
                               --merge --no-backup-if-mismatch; then
    die "Failed to apply ${1##*/}"
  fi
}

build() {
  die "Package neither declares mode nor defines build()"
}

check() { :; }

die() {
  if [[ $# -gt 0 ]]; then
    printf '%s\n' "$@" >&2
  fi
  exit 1
}

disable() {
  while [[ $# -gt 0 ]]; do
    unset "FEATURES[$1]"
    shift
  done
}

enable() {
  while [[ $# -gt 0 ]]; do
    if [[ $1 == *=* ]]; then
      if [[ ${FEATURES[${1%%=*}]} != ?(${1#*=}) ]]; then
        die "Conflicting type requirements for feature ${1%%=*}"
      fi
      FEATURES[${1%%=*}]=${1#*=}
    elif [[ -z ${FEATURES[$1]+defined} ]]; then
      FEATURES[$1]=
    fi
    shift
  done
}

enabled() {
  while [[ $# -gt 0 ]]; do
    if [[ -z ${FEATURES[${1%%=*}]+defined} ]]; then
      return 1
    elif [[ $1 == *=* ]] && [[ ${FEATURES[${1%%=*}]} != ${1#*=} ]]; then
      return 1
    fi
    shift
  done
}

feature() {
  if [[ -z ${FEATURES[$1]+defined} ]]; then
    return 1
  elif [[ -n ${FEATURES[$1]} ]]; then
    printf '%s\n' "${FEATURES[$1]}"
  fi
}

fetch() {
  if [[ $# -lt 2 ]]; then
    set -- "${1##*/}" "$1"
  fi

  if [[ -f $2 ]]; then
    cat "$2"
  elif [[ $2 == /* ]]; then
    die "$1 not found"
  elif [[ -d $CACHEDIR && -n $1 ]]; then
    if [[ ! -f $CACHEDIR/$1 ]]; then
      echo "Downloading $1 from $2:" >&2
      if ! curl -f -o "$CACHEDIR/$1.part" -C - -L "$2"; then
        die "Failed to fetch $2"
      fi
      mv "$CACHEDIR/$1.part" "$CACHEDIR/$1"
    fi
    cat "$CACHEDIR/$1"
  elif ! curl -f -L "$2"; then
    die "Failed to fetch $2"
  fi
}

hashtree() {
  set -- . -mindepth 1 "$@"
  local ARG; for (( ARG = 4; ARG <= $#; ARG += 4 )); do
    set -- "${@:1:ARG - 1}" -path "./${!ARG}" -prune -or "${@:ARG + 1}"
  done

  find "$@" -type d -or -type l -or -type f -not -perm /ug+s -or \
    -printf "Illegal node $PWD/%P\\n" -exec false {} + >&2

  if find "$@" -type l -exec realpath -m -z --relative-to="$1" {} + \
       | grep -q -z '^\.\./'; then
    die "Illegal symlink $PWD/%P"
  fi

  { find "$@" -type d -printf "%P\0" | LC_ALL=C sort -z
    printf '\0'
    find "$@" -type l -printf "%P\0%l\0" | LC_ALL=C sort -z
    printf '\0'
    find "$@" -type f -executable -printf "%P\0" | LC_ALL=C sort -z \
      | xargs -0 b2sum -l 256 -z | cut -b 1-65,67- -z
    printf '\0'
    find "$@" -type f -not -executable -printf "%P\0" | LC_ALL=C sort -z \
      | xargs -0 b2sum -l 256 -z | cut -b 1-65,67- -z
    printf '\0'
  } | b2sum -l 256 | cut -b 1-64
}

locate() {
  if [[ $2 == ?(.|..)/* ]] && [[ -f $2/build ]]; then
    printf '%s\n' "${2%%*(/)}"
  elif [[ $2 != ?(.|..)/* ]] && [[ -f $1/$2/build ]]; then
    printf '%s\n' "$1/${2%%*(/)}"
  else
    die "Package ${2%%*(/)} not found"
  fi
}

maybe() {
  [[ ${@:$#} == "--" ]] || "$@"
}

mode() {
  if [[ -f $LIBRARY/modes/$1 ]]; then
    source "$LIBRARY/modes/$1"
  else
    die "Unrecognised build mode: $1"
  fi
}

populate() {
  mkdir -m 0755 -p "$1"/{bin,dev,etc,lib,proc,run}
  mkdir -m 1777 -p "$1"/{run/shm,tmp}
  cp -n -t "$1/etc" -L -R /etc/{protocols,resolv.conf,services,ssl} \
    "$LIBRARY/skel/passwd" "$LIBRARY/skel/group"
  resolve "${@:2}" | while read IMG; do
    maybe cp -a -l -t "$1" -- "$IMGDIR/$IMG"/!(info)
  done
}

prepare() {
  die "Package does not define prepare()"
}

require() {
  while [[ $# -gt 0 ]]; do
    REQUIREMENTS[$1]=1
    shift
  done
}

resolve() {
  declare -A IMAGES=()
  while [[ $# -gt 0 ]]; do
    declare -a REQUIRED=()
    if [[ -n $1 ]] && ! let "IMAGES[$1]++"; then
      if [[ -f $IMGDIR/$1 ]]; then
        mapfile -t REQUIRED < "$IMGDIR/$1"
      elif [[ -d $IMGDIR/$1 ]]; then
        printf '%s\n' "$1"
        if [[ -f $IMGDIR/$1/info/requirements ]]; then
          mapfile -t REQUIRED < "$IMGDIR/$1/info/requirements"
        fi
      else
        die "Required image $1 not found in $IMGDIR"
      fi
    fi
    set -- "${REQUIRED[@]}" "${@:2}"
  done
}

setup() {
  set -o allexport
  unset CFLAGS LDFLAGS
  CHOST=$(cc -dumpmachine)
  MAKEFLAGS=-j$((1 + $(nproc)))
  set +o allexport

  while [[ $# -gt 0 ]]; do
    if [[ $1 == no-* ]]; then
      disable "${1#no-}"
    else
      enable "$1"
    fi
    shift
  done
}

tidy() {
  find "$@" -type d -exec chown -f 0:0 {} + -exec chmod -f u=rwx,go=rx {} +
  find "$@" -type f -not -perm /ug+s -exec chown -f 0:0 {} + \
    -exec chmod -f u=rwX,go=rX {} +
  find "$@" -type f -perm /ug+s -exec chmod -f u+rw,go+r {} +

  for IMG in "$@"; do
    if [[ -d $IMG ]]; then
      rm -f -r "$IMG"/{etc,run,tmp,var,lib/pkgconfig,lib/**/*.la}
      if ! enabled docs; then
        rm -f -r "$IMG"/lib/{doc,info,man}
      fi

      mkdir -p "$IMG"/lib/{shared,static}
      maybe mv -t "$IMG"/lib/static -- "$IMG"/lib{,/shared}/*.[ao]
      maybe mv -t "$IMG"/lib/shared -- "$IMG"/lib{,/static}/!(ld*).so?(.*)
      maybe chmod -f u=rw,go=r -- "$IMG"/lib/**/{*.so,*.so.*}
      maybe chmod -f a+x -- "$IMG"/lib/ld*.so?(.*)
      find "$IMG" -mindepth 1 -depth -type d -empty -delete

      find "$IMG" -type f -print0 | while read -d '' -r FILE; do
        if [[ $(hexdump -e '/1 "%02x"' -n 4 -v "$FILE") == 7f454c46 ]]; then
          # ELF executable or shared object
          if readelf -d "$FILE" | grep -q ' (R\(UN\)\?PATH) ' \
               && ! enabled rpaths; then
            echo "$FILE has been compiled with an RPATH or RUNPATH"
          fi
          if ! enabled unstripped; then
            strip --strip-unneeded "$FILE"
          fi
        elif [[ $(hexdump -e '/1 "%02x"' -n 2 -v "$FILE") == 2321 ]]; then
          # Script with '#!' magic
          sed -e '1s:^#! *//*:#!/:' \
              -e '1s:^#!/usr/local/:#!/:' \
              -e '1s:^#!/usr/:#!/:' \
              -e '1s:^#!/bin/env  *\([^ =][^ =]*\)\( \|$\):#!/bin/\1\2:' \
              -i "$FILE"
        else
          chmod u=rw,go=r "$FILE"
        fi

        if [[ -u $FILE ]] && ! enabled setuid; then
          echo "$FILE has been installed setuid"
        elif [[ -g $FILE ]] && ! enabled setgid; then
          echo "$FILE has been installed setgid"
        fi
      done

      find "$IMG" -mindepth 1 -path "$IMG/bin" -type d -prune \
        -or -path "$IMG/lib" -type d -prune \
        -or -path "$IMG/info" -type d -prune \
        -or -printf "%p is neither in $IMG/bin nor $IMG/lib\n"

      find "$IMG" -lname '/*' -printf '%p is an absolute symlink\n' \
        -or -xtype l -printf '%p is a dangling symlink\n' \
        -or -not -xtype d -not -xtype f -printf '%p is a special file\n'

      if [[ -d $IMG/bin ]]; then
        find "$IMG/bin" -mindepth 1 -xtype d -printf '%p is a directory\n' \
          -or -xtype f -executable -or -printf '%p is not executable\n'
      fi
    fi
  done | [[ -z $(tee /dev/stderr) ]]

  hardlink -q -t "$@"
  find "$@" -maxdepth 0 -type d -empty -delete
}

tree() {
  hashtree "${@:2}" | while read HASH; do
    if [[ $# -eq 0 ]]; then
      caller | while read LINE FILE; do
        if sed -e "$LINE s/^\\([[:blank:]]*tree\\)[[:blank:]]*\$/\\1 $HASH/" \
               -i "$FILE" 2>/dev/null; then
          warn "Updated source tree hash at $FILE:$LINE"
        else
          warn "Failed to update source tree hash at $FILE:$LINE"
        fi
      done
    elif [[ $1 != $HASH ]]; then
      caller | while read LINE FILE; do
        die "Source tree hash mismatch at $FILE:$LINE"
      done
    fi
  done
}

unpack() {
  local DIR OPTARG OPTIND OPTION STRIP=1
  while getopts :d:p: OPTION; do
    case $OPTION in
      d)
        if ! mkdir -p -- "$OPTARG" 2>/dev/null; then
          die "Failed to create directory $OPTARG"
        fi
        DIR=$OPTARG
        ;;
      p)
        if [[ $OPTARG != @(0|[1-9]*([0-9])) ]]; then
          die "Invalid prefix length to strip"
        fi
        STRIP=$OPTARG
        ;;
    esac
  done
  shift $((OPTIND - 1))

  if [[ $# -eq 1 ]] && [[ -f $PKG/$1 ]]; then
    set -- "$PKG/$1"
  fi

  if fetch "$@" | tar -x -f - -C "${DIR:-.}" --no-same-owner \
                    --no-same-permissions --strip-components=$STRIP; then
    chmod -R u=rwX,go=rX "${DIR:-.}"
  else
    die "Failed to unpack ${1##*/}"
  fi
}

warn() {
  if [[ $# -gt 0 ]]; then
    printf '%s\n' "$@" >&2
  fi
}
