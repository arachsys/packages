diff --git a/library/stat.c b/library/stat.c
index 60d7364458c9c16715f5e1d67e9861b72fa2adef..a8e0d465743836bcc54d7171bb06c524d9ecb267 100644
--- a/library/stat.c
+++ b/library/stat.c
@@ -455,7 +455,8 @@ static int stat_core_add (
 static void stat_cores_check (
     struct stat_info *info)
 {
-    struct stat_core *core = info->cores;
+    struct stat_core *core;
+#ifndef PRETEND_E_CORES
     int p_core = 0;
 
     core = info->cores;
@@ -473,6 +474,16 @@ static void stat_cores_check (
                 core->type = E_CORE;
         } while ((core = core->next));
     }
+#else
+    core = info->cores;
+    while (core) {
+        core->type = P_CORE;
+        if (core->thread_1 > ECORE_BEGIN
+        || (core->thread_2 > ECORE_BEGIN))
+            core->type = E_CORE;
+        core = core->next;
+    }
+#endif
 } // end: stat_cores_check
 
 #undef E_CORE
@@ -519,19 +530,16 @@ static int stat_cores_verify (
                 errno = EIO;
                 return 0;
             }
+            if (buf[0] == '\n') {     /* Entry for specific processor is finished */
+                a_core = a_cpu;
+                break;
+            }
             if (buf[0] != 'c') continue;
             if (!strstr(buf, "core id"))
                 continue;
             sscanf(buf, "core id : %d", &a_core);
             break;
         }
-#ifdef PRETEND_E_CORES
-      { static int fake_core;
-        if (a_cpu > ECORE_BEGIN) {
-            if (!fake_core) fake_core = a_core + 1;
-            a_core = fake_core++;
-      } }
-#endif
         if (!stat_core_add(info, a_core, a_cpu)) {
             fclose(fp);
             return 0;
@@ -831,8 +839,13 @@ reap_em_again:
     /* whoa, if a new cpu was brought online, we better
        ensure that no new cores have now become visible */
     if (info->cpu_count_hwm < info->cpus.total) {
-        if (!stat_cores_verify(info))
-            return 1;
+        /* next means it's not the first time, so we'll re-verify.
+           otherwise, procps_stat_new() already setup any cores so
+           that they could be linked above during tics processing. */
+        if (info->cpu_count_hwm) {
+            if (!stat_cores_verify(info))
+                return 1;
+        }
         info->cpu_count_hwm = info->cpus.total;
     }
 
diff --git a/src/top/top.c b/src/top/top.c
index e595cd8456b10f7ab88fa8a0970d456d0f2634e1..fae38bd8ff142d84da9fe9da5c043e7c6197940c 100644
--- a/src/top/top.c
+++ b/src/top/top.c
@@ -2734,9 +2734,10 @@ static void *cpus_refresh (void *unused) {
 #endif
       }
 #ifdef PRETENDECORE
-{  int i;
-   for (i = Cpu_cnt - (Cpu_cnt / 4); i < Cpu_cnt; i++)
-      Stat_reap->cpus->stacks[i]->head[stat_COR_TYP].result.s_int = E_CORE;
+{  int i, x;
+   x = Cpu_cnt - (Cpu_cnt / 4);
+   for (i = 0; i < Cpu_cnt; i++)
+      Stat_reap->cpus->stacks[i]->head[stat_COR_TYP].result.s_int = (i < x) ? P_CORE : E_CORE;
 }
 #endif
 #ifdef THREADED_CPU
