diff --git a/compiler/rustc_target/src/spec/crt_objects.rs b/compiler/rustc_target/src/spec/crt_objects.rs
index 51f392a64..c4d1729d5 100644
--- a/compiler/rustc_target/src/spec/crt_objects.rs
+++ b/compiler/rustc_target/src/spec/crt_objects.rs
@@ -63,6 +63,7 @@ pub(super) fn all(obj: &'static str) -> CrtObjects {
     ])
 }
 
+#[allow(dead_code)]
 pub(super) fn pre_musl_fallback() -> CrtObjects {
     new(&[
         (LinkOutputKind::DynamicNoPicExe, &["crt1.o", "crti.o", "crtbegin.o"]),
@@ -74,6 +75,7 @@ pub(super) fn pre_musl_fallback() -> CrtObjects {
     ])
 }
 
+#[allow(dead_code)]
 pub(super) fn post_musl_fallback() -> CrtObjects {
     new(&[
         (LinkOutputKind::DynamicNoPicExe, &["crtend.o", "crtn.o"]),
diff --git a/compiler/rustc_target/src/spec/linux_musl_base.rs b/compiler/rustc_target/src/spec/linux_musl_base.rs
index 207a87ab0..0108e8dcb 100644
--- a/compiler/rustc_target/src/spec/linux_musl_base.rs
+++ b/compiler/rustc_target/src/spec/linux_musl_base.rs
@@ -1,16 +1,7 @@
-use crate::spec::crt_objects::{self, CrtObjectsFallback};
 use crate::spec::TargetOptions;
 
 pub fn opts() -> TargetOptions {
     let mut base = super::linux_base::opts();
-
     base.env = "musl".into();
-    base.pre_link_objects_fallback = crt_objects::pre_musl_fallback();
-    base.post_link_objects_fallback = crt_objects::post_musl_fallback();
-    base.crt_objects_fallback = Some(CrtObjectsFallback::Musl);
-
-    // These targets statically link libc by default
-    base.crt_static_default = true;
-
     base
 }
diff --git a/src/bootstrap/compile.rs b/src/bootstrap/compile.rs
index afc333b50..1a99c3fa4 100644
--- a/src/bootstrap/compile.rs
+++ b/src/bootstrap/compile.rs
@@ -196,40 +196,7 @@ fn copy_self_contained_objects(
     t!(fs::create_dir_all(&libdir_self_contained));
     let mut target_deps = vec![];
 
-    // Copies the libc and CRT objects.
-    //
-    // rustc historically provides a more self-contained installation for musl targets
-    // not requiring the presence of a native musl toolchain. For example, it can fall back
-    // to using gcc from a glibc-targeting toolchain for linking.
-    // To do that we have to distribute musl startup objects as a part of Rust toolchain
-    // and link with them manually in the self-contained mode.
-    if target.contains("musl") {
-        let srcdir = builder.musl_libdir(target).unwrap_or_else(|| {
-            panic!("Target {:?} does not have a \"musl-libdir\" key", target.triple)
-        });
-        for &obj in &["libc.a", "crt1.o", "Scrt1.o", "rcrt1.o", "crti.o", "crtn.o"] {
-            copy_and_stamp(
-                builder,
-                &libdir_self_contained,
-                &srcdir,
-                obj,
-                &mut target_deps,
-                DependencyType::TargetSelfContained,
-            );
-        }
-        let crt_path = builder.ensure(native::CrtBeginEnd { target });
-        for &obj in &["crtbegin.o", "crtbeginS.o", "crtend.o", "crtendS.o"] {
-            let src = crt_path.join(obj);
-            let target = libdir_self_contained.join(obj);
-            builder.copy(&src, &target);
-            target_deps.push((target, DependencyType::TargetSelfContained));
-        }
-
-        if !target.starts_with("s390x") {
-            let libunwind_path = copy_llvm_libunwind(builder, target, &libdir_self_contained);
-            target_deps.push((libunwind_path, DependencyType::TargetSelfContained));
-        }
-    } else if target.ends_with("-wasi") {
+    if target.ends_with("-wasi") {
         let srcdir = builder
             .wasi_root(target)
             .unwrap_or_else(|| {
diff --git a/src/bootstrap/dist.rs b/src/bootstrap/dist.rs
index be965971d..37ce488a0 100644
--- a/src/bootstrap/dist.rs
+++ b/src/bootstrap/dist.rs
@@ -976,7 +976,7 @@ impl Step for Cargo {
         for dirent in fs::read_dir(cargo.parent().unwrap()).expect("read_dir") {
             let dirent = dirent.expect("read dir entry");
             if dirent.file_name().to_str().expect("utf8").starts_with("cargo-credential-") {
-                tarball.add_file(&dirent.path(), "libexec", 0o755);
+                tarball.add_file(&dirent.path(), "bin", 0o755);
             }
         }
 
diff --git a/src/bootstrap/lib.rs b/src/bootstrap/lib.rs
index 570a61742..dd383c8cc 100644
--- a/src/bootstrap/lib.rs
+++ b/src/bootstrap/lib.rs
@@ -311,6 +311,7 @@ pub struct Build {
         RefCell<HashMap<TargetSelection, HashMap<String, (&'static str, PathBuf, Vec<String>)>>>,
 }
 
+#[allow(dead_code)]
 #[derive(Debug)]
 struct Crate {
     name: Interned<String>,
diff --git a/src/bootstrap/sanity.rs b/src/bootstrap/sanity.rs
index 8c2899c1a..dda15d764 100644
--- a/src/bootstrap/sanity.rs
+++ b/src/bootstrap/sanity.rs
@@ -11,7 +11,6 @@
 use std::collections::HashMap;
 use std::env;
 use std::ffi::{OsStr, OsString};
-use std::fs;
 use std::path::PathBuf;
 use std::process::Command;
 
@@ -177,28 +176,6 @@ pub fn check(build: &mut Build) {
             }
         }
 
-        // Make sure musl-root is valid
-        if target.contains("musl") {
-            // If this is a native target (host is also musl) and no musl-root is given,
-            // fall back to the system toolchain in /usr before giving up
-            if build.musl_root(*target).is_none() && build.config.build == *target {
-                let target = build.config.target_config.entry(*target).or_default();
-                target.musl_root = Some("/usr".into());
-            }
-            match build.musl_libdir(*target) {
-                Some(libdir) => {
-                    if fs::metadata(libdir.join("libc.a")).is_err() {
-                        panic!("couldn't find libc.a in musl libdir: {}", libdir.display());
-                    }
-                }
-                None => panic!(
-                    "when targeting MUSL either the rust.musl-root \
-                            option or the target.$TARGET.musl-root option must \
-                            be specified in config.toml"
-                ),
-            }
-        }
-
         if need_cmake && target.contains("msvc") {
             // There are three builds of cmake on windows: MSVC, MinGW, and
             // Cygwin. The Cygwin build does not have generators for Visual
diff --git a/src/tools/cargo/src/cargo/ops/registry/auth.rs b/src/tools/cargo/src/cargo/ops/registry/auth.rs
index 648e051e6..924703ae5 100644
--- a/src/tools/cargo/src/cargo/ops/registry/auth.rs
+++ b/src/tools/cargo/src/cargo/ops/registry/auth.rs
@@ -224,7 +224,7 @@ fn sysroot_credential(
         .parent()
         .and_then(|p| p.parent())
         .ok_or_else(|| format_err!("expected cargo path {}", cargo.display()))?;
-    let exe = root.join("libexec").join(format!(
+    let exe = root.join("bin").join(format!(
         "cargo-credential-{}{}",
         cred_name,
         std::env::consts::EXE_SUFFIX
